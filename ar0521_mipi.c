/*
 * A V4L2 driver for ar0330_mipi Raw cameras.
 *
 */
#include <linux/init.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/delay.h>
#include <linux/videodev2.h>
#include <linux/clk.h>
#include <media/v4l2-device.h>
#include <media/v4l2-chip-ident.h>
#include <media/v4l2-mediabus.h>
#include <linux/io.h>


#include "camera.h"


MODULE_AUTHOR("Chomoly");
MODULE_DESCRIPTION("A low-level driver for Aptina ar0521_mipi Raw sensors");
MODULE_LICENSE("GPL");

//for internel driver debug
#define DEV_DBG_EN      1 
#if(DEV_DBG_EN == 1)    
#define vfe_dev_dbg(x,arg...) printk("[ar0521_mipi Raw]"x,##arg)
#else
#define vfe_dev_dbg(x,arg...) 
#endif
#define vfe_dev_err(x,arg...) printk("[ar0521_mipi Raw]"x,##arg)
#define vfe_dev_print(x,arg...) printk("[ar0521_mipi Raw]"x,##arg)

#define LOG_ERR_RET(x)  { \
                          int ret;  \
                          ret = x; \
                          if(ret < 0) {\
                            vfe_dev_err("error at %s\n",__func__);  \
                            return ret; \
                          } \
                        }

//define module timing
#define MCLK              (24*1000*1000)
#define VREF_POL          V4L2_MBUS_VSYNC_ACTIVE_HIGH
#define HREF_POL          V4L2_MBUS_HSYNC_ACTIVE_HIGH
#define CLK_POL           V4L2_MBUS_PCLK_SAMPLE_RISING
#define V4L2_IDENT_SENSOR  0x0521


//define the voltage level of control signal
#define CSI_STBY_ON     1
#define CSI_STBY_OFF    0
#define CSI_RST_ON      0
#define CSI_RST_OFF     1
#define CSI_PWR_ON      1
#define CSI_PWR_OFF     0
#define CSI_AF_PWR_ON   1
#define CSI_AF_PWR_OFF  0
#define regval_list reg_list_a16_d16
#define SENSOR_NAME "ar0521_mipi"



#define REG_TERM 0xfffe
#define VAL_TERM 0xfe
#define REG_DLY  0xffff

/*
 *Our nominal (default) frame rate.
 */

#define SENSOR_FRAME_RATE 30


/*
 * The ar0330_mipi i2c address
 */
#define I2C_ADDR 0x6C


//static struct delayed_work sensor_s_ae_ratio_work;
static struct v4l2_subdev *glb_sd;

/*
 * Information we maintain about a known sensor.
 */
struct sensor_format_struct;  /* coming later */

struct cfg_array { /* coming later */
	struct regval_list * regs;
	int size;
};

static inline struct sensor_info *to_state(struct v4l2_subdev *sd)
{
    return container_of(sd, struct sensor_info, sd);
}


/*
 * The default register settings
 *
 */

static struct regval_list sensor_default_regs[] = 
{
#if 0
    { 0x0103, 0x0001},   ///software_reset
	{ REG_DLY,0x0064},	//DELAY= 100
//DELAY= 100
	{ 0x3042, 0x0000}, // DARK_CONTROL2
	{ 0x3044, 0x4580}, // DARK_CONTROL
	{ 0x30EE, 0x1140}, // DARK_CONTROL3
	{ 0x3120, 0x0001}, // GAIN_DITHER_CONTROL
	{ 0x3F2C, 0x772E}, // GTH_THRES_RTN
	{ 0x30D2, 0x0000}, // CRM_CONTROL
	{ 0x30D4, 0x0000}, // COLUMN_CORRECTION
	{ 0x30D6, 0x2FFF}, // COLUMN_CORRECTION2
	{ 0x30DA, 0x0FFF}, // COLUMN_CORRECTION_CLIP2
	{ 0x30DC, 0x0FFF}, // COLUMN_CORRECTION_CLIP3
	{ 0x30DE, 0x0000}, // COLUMN_GROUP_CORRECTION
	{ 0x31E0, 0x0781}, // PIX_DEF_ID
	{ 0x3180, 0x9434}, // FINE_DIG_CORRECTION_CONTROL
	{ 0x3172, 0x0206}, // ANALOG_CONTROL2
	{ 0x3F00, 0x0017}, // BM_T0
	{ 0x3F02, 0x02DD}, // BM_T1
	{ 0x3F04, 0x0020}, // NOISE_GAIN_THRESHOLD0
	{ 0x3F08, 0x0070}, // NOISE_GAIN_THRESHOLD2
	{ 0x3F0A, 0x0101}, // NOISE_FLOOR10
	{ 0x3F0C, 0x0302}, // NOISE_FLOOR32
	{ 0x3F1E, 0x0022}, // NOISE_COEF
	{ 0x3F1A, 0x01FF}, // CROSSFACTOR2
	{ 0x3F14, 0x0505}, // SINGLE_K_FACTOR2
	{ 0x3F44, 0x0707}, // COUPLE_K_FACTOR2
	{ 0x3F18, 0x01FF}, // CROSSFACTOR1
	{ 0x3F12, 0x0505}, // SINGLE_K_FACTOR1
	{ 0x3F42, 0x1511}, // COUPLE_K_FACTOR1
	{ 0x3F16, 0x01FF}, // CROSSFACTOR0
	{ 0x3F10, 0x0505}, // SINGLE_K_FACTOR0
	{ 0x3F40, 0x1511}, // COUPLE_K_FACTOR0
	{ 0x3D00, 0x043E}, // DYNAMIC_SEQRAM_00
	{ 0x3D02, 0x4760}, // DYNAMIC_SEQRAM_02
	{ 0x3D04, 0xFFFF}, // DYNAMIC_SEQRAM_04
	{ 0x3D06, 0xFFFF}, // DYNAMIC_SEQRAM_06
	{ 0x3D08, 0x8000}, // DYNAMIC_SEQRAM_08
	{ 0x3D0A, 0x0510}, // DYNAMIC_SEQRAM_0A
	{ 0x3D0C, 0xAF08}, // DYNAMIC_SEQRAM_0C
	{ 0x3D0E, 0x0252}, // DYNAMIC_SEQRAM_0E
	{ 0x3D10, 0x486F}, // DYNAMIC_SEQRAM_10
	{ 0x3D12, 0x5D5D}, // DYNAMIC_SEQRAM_12
	{ 0x3D14, 0x8056}, // DYNAMIC_SEQRAM_14
	{ 0x3D16, 0x8313}, // DYNAMIC_SEQRAM_16
	{ 0x3D18, 0x0087}, // DYNAMIC_SEQRAM_18
	{ 0x3D1A, 0x6A48}, // DYNAMIC_SEQRAM_1A
	{ 0x3D1C, 0x6982}, // DYNAMIC_SEQRAM_1C
	{ 0x3D1E, 0x0280}, // DYNAMIC_SEQRAM_1E
	{ 0x3D20, 0x8359}, // DYNAMIC_SEQRAM_20
	{ 0x3D22, 0x8D02}, // DYNAMIC_SEQRAM_22
	{ 0x3D24, 0x8020}, // DYNAMIC_SEQRAM_24
	{ 0x3D26, 0x4882}, // DYNAMIC_SEQRAM_26
	{ 0x3D28, 0x4269}, // DYNAMIC_SEQRAM_28
	{ 0x3D2A, 0x6A95}, // DYNAMIC_SEQRAM_2A
	{ 0x3D2C, 0x5988}, // DYNAMIC_SEQRAM_2C
	{ 0x3D2E, 0x5A83}, // DYNAMIC_SEQRAM_2E
	{ 0x3D30, 0x5885}, // DYNAMIC_SEQRAM_30
	{ 0x3D32, 0x6280}, // DYNAMIC_SEQRAM_32
	{ 0x3D34, 0x6289}, // DYNAMIC_SEQRAM_34
	{ 0x3D36, 0x6097}, // DYNAMIC_SEQRAM_36
	{ 0x3D38, 0x5782}, // DYNAMIC_SEQRAM_38
	{ 0x3D3A, 0x605C}, // DYNAMIC_SEQRAM_3A
	{ 0x3D3C, 0xBF18}, // DYNAMIC_SEQRAM_3C
	{ 0x3D3E, 0x0961}, // DYNAMIC_SEQRAM_3E
	{ 0x3D40, 0x5080}, // DYNAMIC_SEQRAM_40
	{ 0x3D42, 0x2090}, // DYNAMIC_SEQRAM_42
	{ 0x3D44, 0x4394}, // DYNAMIC_SEQRAM_44
	{ 0x3D46, 0x5F8A}, // DYNAMIC_SEQRAM_46
	{ 0x3D48, 0x5D5D}, // DYNAMIC_SEQRAM_48
	{ 0x3D4A, 0x8D43}, // DYNAMIC_SEQRAM_4A
	{ 0x3D4C, 0x8D63}, // DYNAMIC_SEQRAM_4C
	{ 0x3D4E, 0x8063}, // DYNAMIC_SEQRAM_4E
	{ 0x3D50, 0xA960}, // DYNAMIC_SEQRAM_50
	{ 0x3D52, 0x9757}, // DYNAMIC_SEQRAM_52
	{ 0x3D54, 0x8260}, // DYNAMIC_SEQRAM_54
	{ 0x3D56, 0x5CFF}, // DYNAMIC_SEQRAM_56
	{ 0x3D58, 0xBF10}, // DYNAMIC_SEQRAM_58
	{ 0x3D5A, 0x1681}, // DYNAMIC_SEQRAM_5A
	{ 0x3D5C, 0x0802}, // DYNAMIC_SEQRAM_5C
	{ 0x3D5E, 0x8000}, // DYNAMIC_SEQRAM_5E
	{ 0x3D60, 0x141C}, // DYNAMIC_SEQRAM_60
	{ 0x3D62, 0x6000}, // DYNAMIC_SEQRAM_62
	{ 0x3D64, 0x6022}, // DYNAMIC_SEQRAM_64
	{ 0x3D66, 0x4D80}, // DYNAMIC_SEQRAM_66
	{ 0x3D68, 0x5C97}, // DYNAMIC_SEQRAM_68
	{ 0x3D6A, 0x6A69}, // DYNAMIC_SEQRAM_6A
	{ 0x3D6C, 0xAC6F}, // DYNAMIC_SEQRAM_6C
	{ 0x3D6E, 0x4645}, // DYNAMIC_SEQRAM_6E
	{ 0x3D70, 0x4400}, // DYNAMIC_SEQRAM_70
	{ 0x3D72, 0x0513}, // DYNAMIC_SEQRAM_72
	{ 0x3D74, 0x8069}, // DYNAMIC_SEQRAM_74
	{ 0x3D76, 0x6AC6}, // DYNAMIC_SEQRAM_76
	{ 0x3D78, 0x5F95}, // DYNAMIC_SEQRAM_78
	{ 0x3D7A, 0x5F70}, // DYNAMIC_SEQRAM_7A
	{ 0x3D7C, 0x8040}, // DYNAMIC_SEQRAM_7C
	{ 0x3D7E, 0x4A81}, // DYNAMIC_SEQRAM_7E
	{ 0x3D80, 0x0300}, // DYNAMIC_SEQRAM_80
	{ 0x3D82, 0xE703}, // DYNAMIC_SEQRAM_82
	{ 0x3D84, 0x0088}, // DYNAMIC_SEQRAM_84
	{ 0x3D86, 0x4A83}, // DYNAMIC_SEQRAM_86
	{ 0x3D88, 0x40FF}, // DYNAMIC_SEQRAM_88
	{ 0x3D8A, 0xFFFF}, // DYNAMIC_SEQRAM_8A
	{ 0x3D8C, 0xFD70}, // DYNAMIC_SEQRAM_8C
	{ 0x3D8E, 0x8040}, // DYNAMIC_SEQRAM_8E
	{ 0x3D90, 0x4A85}, // DYNAMIC_SEQRAM_90
	{ 0x3D92, 0x4FA8}, // DYNAMIC_SEQRAM_92
	{ 0x3D94, 0x4F8C}, // DYNAMIC_SEQRAM_94
	{ 0x3D96, 0x0070}, // DYNAMIC_SEQRAM_96
	{ 0x3D98, 0xBE47}, // DYNAMIC_SEQRAM_98
	{ 0x3D9A, 0x8847}, // DYNAMIC_SEQRAM_9A
	{ 0x3D9C, 0xBC78}, // DYNAMIC_SEQRAM_9C
	{ 0x3D9E, 0x6B89}, // DYNAMIC_SEQRAM_9E
	{ 0x3DA0, 0x6A80}, // DYNAMIC_SEQRAM_A0
	{ 0x3DA2, 0x6986}, // DYNAMIC_SEQRAM_A2
	{ 0x3DA4, 0x6B8E}, // DYNAMIC_SEQRAM_A4
	{ 0x3DA6, 0x6B80}, // DYNAMIC_SEQRAM_A6
	{ 0x3DA8, 0x6980}, // DYNAMIC_SEQRAM_A8
	{ 0x3DAA, 0x6A88}, // DYNAMIC_SEQRAM_AA
	{ 0x3DAC, 0x7C9F}, // DYNAMIC_SEQRAM_AC
	{ 0x3DAE, 0x866B}, // DYNAMIC_SEQRAM_AE
	{ 0x3DB0, 0x8765}, // DYNAMIC_SEQRAM_B0
	{ 0x3DB2, 0x46FF}, // DYNAMIC_SEQRAM_B2
	{ 0x3DB4, 0xE365}, // DYNAMIC_SEQRAM_B4
	{ 0x3DB6, 0xA679}, // DYNAMIC_SEQRAM_B6
	{ 0x3DB8, 0x4A40}, // DYNAMIC_SEQRAM_B8
	{ 0x3DBA, 0x4580}, // DYNAMIC_SEQRAM_BA
	{ 0x3DBC, 0x44BC}, // DYNAMIC_SEQRAM_BC
	{ 0x3DBE, 0x7000}, // DYNAMIC_SEQRAM_BE
	{ 0x3DC0, 0x8040}, // DYNAMIC_SEQRAM_C0
	{ 0x3DC2, 0x0802}, // DYNAMIC_SEQRAM_C2
	{ 0x3DC4, 0x10EF}, // DYNAMIC_SEQRAM_C4
	{ 0x3DC6, 0x0104}, // DYNAMIC_SEQRAM_C6
	{ 0x3DC8, 0x3860}, // DYNAMIC_SEQRAM_C8
	{ 0x3DCA, 0x5D80}, // DYNAMIC_SEQRAM_CA
	{ 0x3DCC, 0x565D}, // DYNAMIC_SEQRAM_CC
	{ 0x3DCE, 0x8113}, // DYNAMIC_SEQRAM_CE
	{ 0x3DD0, 0x0086}, // DYNAMIC_SEQRAM_D0
	{ 0x3DD2, 0x4882}, // DYNAMIC_SEQRAM_D2
	{ 0x3DD4, 0x0280}, // DYNAMIC_SEQRAM_D4
	{ 0x3DD6, 0x8259}, // DYNAMIC_SEQRAM_D6
	{ 0x3DD8, 0x8A02}, // DYNAMIC_SEQRAM_D8
	{ 0x3DDA, 0x8020}, // DYNAMIC_SEQRAM_DA
	{ 0x3DDC, 0x4830}, // DYNAMIC_SEQRAM_DC
	{ 0x3DDE, 0x6080}, // DYNAMIC_SEQRAM_DE
	{ 0x3DE0, 0x4292}, // DYNAMIC_SEQRAM_E0
	{ 0x3DE2, 0x5986}, // DYNAMIC_SEQRAM_E2
	{ 0x3DE4, 0x5A82}, // DYNAMIC_SEQRAM_E4
	{ 0x3DE6, 0x5885}, // DYNAMIC_SEQRAM_E6
	{ 0x3DE8, 0x6280}, // DYNAMIC_SEQRAM_E8
	{ 0x3DEA, 0x6285}, // DYNAMIC_SEQRAM_EA
	{ 0x3DEC, 0x6092}, // DYNAMIC_SEQRAM_EC
	{ 0x3DEE, 0x5782}, // DYNAMIC_SEQRAM_EE
	{ 0x3DF0, 0x2110}, // DYNAMIC_SEQRAM_F0
	{ 0x3DF2, 0xFFB7}, // DYNAMIC_SEQRAM_F2
	{ 0x3DF4, 0x5793}, // DYNAMIC_SEQRAM_F4
	{ 0x3DF6, 0x6110}, // DYNAMIC_SEQRAM_F6
	{ 0x3DF8, 0x1980}, // DYNAMIC_SEQRAM_F8
	{ 0x3DFA, 0x2090}, // DYNAMIC_SEQRAM_FA
	{ 0x3DFC, 0x4394}, // DYNAMIC_SEQRAM_FC
	{ 0x3DFE, 0x5F83}, // DYNAMIC_SEQRAM_FE
	{ 0x3E00, 0x5D80}, // DYNAMIC_SEQRAM_100
	{ 0x3E02, 0x5D81}, // DYNAMIC_SEQRAM_102
	{ 0x3E04, 0x6380}, // DYNAMIC_SEQRAM_104
	{ 0x3E06, 0x6384}, // DYNAMIC_SEQRAM_106
	{ 0x3E08, 0x439A}, // DYNAMIC_SEQRAM_108
	{ 0x3E0A, 0x6091}, // DYNAMIC_SEQRAM_10A
	{ 0x3E0C, 0x5782}, // DYNAMIC_SEQRAM_10C
	{ 0x3E0E, 0x605C}, // DYNAMIC_SEQRAM_10E
	{ 0x3E10, 0xFFFF}, // DYNAMIC_SEQRAM_110
	{ 0x3E12, 0xFFFF}, // DYNAMIC_SEQRAM_112
	{ 0x3E14, 0xE510}, // DYNAMIC_SEQRAM_114
	{ 0x3E16, 0x1620}, // DYNAMIC_SEQRAM_116
	{ 0x3E18, 0x4808}, // DYNAMIC_SEQRAM_118
	{ 0x3E1A, 0x021C}, // DYNAMIC_SEQRAM_11A
	{ 0x3E1C, 0x6000}, // DYNAMIC_SEQRAM_11C
	{ 0x3E1E, 0x1400}, // DYNAMIC_SEQRAM_11E
	{ 0x3E20, 0x6022}, // DYNAMIC_SEQRAM_120
	{ 0x3E22, 0x0581}, // DYNAMIC_SEQRAM_122
	{ 0x3E24, 0x2090}, // DYNAMIC_SEQRAM_124
	{ 0x3E26, 0x8F6A}, // DYNAMIC_SEQRAM_126
	{ 0x3E28, 0x8069}, // DYNAMIC_SEQRAM_128
	{ 0x3E2A, 0x825F}, // DYNAMIC_SEQRAM_12A
	{ 0x3E2C, 0x9F6F}, // DYNAMIC_SEQRAM_12C
	{ 0x3E2E, 0x4645}, // DYNAMIC_SEQRAM_12E
	{ 0x3E30, 0x4400}, // DYNAMIC_SEQRAM_130
	{ 0x3E32, 0x0580}, // DYNAMIC_SEQRAM_132
	{ 0x3E34, 0x1380}, // DYNAMIC_SEQRAM_134
	{ 0x3E36, 0x696A}, // DYNAMIC_SEQRAM_136
	{ 0x3E38, 0x8070}, // DYNAMIC_SEQRAM_138
	{ 0x3E3A, 0x0000}, // DYNAMIC_SEQRAM_13A
	{ 0x3E3C, 0x0000}, // DYNAMIC_SEQRAM_13C
	{ 0x3E3E, 0x0000}, // DYNAMIC_SEQRAM_13E
	{ 0x3E40, 0x0000}, // DYNAMIC_SEQRAM_140
	{ 0x3E42, 0x0000}, // DYNAMIC_SEQRAM_142
	{ 0x3E44, 0x0000}, // DYNAMIC_SEQRAM_144
	{ 0x3E46, 0x0000}, // DYNAMIC_SEQRAM_146
	{ 0x3E48, 0x0000}, // DYNAMIC_SEQRAM_148
	{ 0x3E4A, 0x0000}, // DYNAMIC_SEQRAM_14A
	{ 0x3E4C, 0x0000}, // DYNAMIC_SEQRAM_14C
	{ 0x3E4E, 0x0000}, // DYNAMIC_SEQRAM_14E
	{ 0x3E50, 0x0000}, // DYNAMIC_SEQRAM_150
	{ 0x3E52, 0x0000}, // DYNAMIC_SEQRAM_152
	{ 0x3E54, 0x0000}, // DYNAMIC_SEQRAM_154
	{ 0x3E56, 0x0000}, // DYNAMIC_SEQRAM_156
	{ 0x3E58, 0x0000}, // DYNAMIC_SEQRAM_158
	{ 0x3E5A, 0x0000}, // DYNAMIC_SEQRAM_15A
	{ 0x3E5C, 0x0000}, // DYNAMIC_SEQRAM_15C
	{ 0x3E5E, 0x0000}, // DYNAMIC_SEQRAM_15E
	{ 0x3E60, 0x0000}, // DYNAMIC_SEQRAM_160
	{ 0x3E62, 0x0000}, // DYNAMIC_SEQRAM_162
	{ 0x3E64, 0x0000}, // DYNAMIC_SEQRAM_164
	{ 0x3E66, 0x0000}, // DYNAMIC_SEQRAM_166
	{ 0x3E68, 0x0000}, // DYNAMIC_SEQRAM_168
	{ 0x3E6A, 0x0000}, // DYNAMIC_SEQRAM_16A
	{ 0x3E6C, 0x0000}, // DYNAMIC_SEQRAM_16C
	{ 0x3E6E, 0x0000}, // DYNAMIC_SEQRAM_16E
	{ 0x3E70, 0x0000}, // DYNAMIC_SEQRAM_170
	{ 0x3E72, 0x0000}, // DYNAMIC_SEQRAM_172
	{ 0x3E74, 0x0000}, // DYNAMIC_SEQRAM_174
	{ 0x3E76, 0x0000}, // DYNAMIC_SEQRAM_176
	{ 0x3E78, 0x0000}, // DYNAMIC_SEQRAM_178
	{ 0x3E7A, 0x0000}, // DYNAMIC_SEQRAM_17A
	{ 0x3E7C, 0x0000}, // DYNAMIC_SEQRAM_17C
	{ 0x3E7E, 0x0000}, // DYNAMIC_SEQRAM_17E
	{ 0x3E80, 0x0000}, // DYNAMIC_SEQRAM_180
	{ 0x3E82, 0x0000}, // DYNAMIC_SEQRAM_182
	{ 0x3E84, 0x0000}, // DYNAMIC_SEQRAM_184
	{ 0x3E86, 0x0000}, // DYNAMIC_SEQRAM_186
	{ 0x3E88, 0x0000}, // DYNAMIC_SEQRAM_188
	{ 0x3E8A, 0x0000}, // DYNAMIC_SEQRAM_18A
	{ 0x3E8C, 0x0000}, // DYNAMIC_SEQRAM_18C
	{ 0x3E8E, 0x0000}, // DYNAMIC_SEQRAM_18E
	{ 0x3E90, 0x0000}, // DYNAMIC_SEQRAM_190
	{ 0x3E92, 0x0000}, // DYNAMIC_SEQRAM_192
	{ 0x3E94, 0x0000}, // DYNAMIC_SEQRAM_194
	{ 0x3E96, 0x0000}, // DYNAMIC_SEQRAM_196
	{ 0x3E98, 0x0000}, // DYNAMIC_SEQRAM_198
	{ 0x3E9A, 0x0000}, // DYNAMIC_SEQRAM_19A
	{ 0x3E9C, 0x0000}, // DYNAMIC_SEQRAM_19C
	{ 0x3E9E, 0x0000}, // DYNAMIC_SEQRAM_19E
	{ 0x3EA0, 0x0000}, // DYNAMIC_SEQRAM_1A0
	{ 0x3EA2, 0x0000}, // DYNAMIC_SEQRAM_1A2
	{ 0x3EA4, 0x0000}, // DYNAMIC_SEQRAM_1A4
	{ 0x3EA6, 0x0000}, // DYNAMIC_SEQRAM_1A6
	{ 0x3EA8, 0x0000}, // DYNAMIC_SEQRAM_1A8
	{ 0x3EAA, 0x0000}, // DYNAMIC_SEQRAM_1AA
	{ 0x3EAC, 0x0000}, // DYNAMIC_SEQRAM_1AC
	{ 0x3EAE, 0x0000}, // DYNAMIC_SEQRAM_1AE
	{ 0x3EB0, 0x0000}, // DYNAMIC_SEQRAM_1B0
	{ 0x3EB2, 0x0000}, // DYNAMIC_SEQRAM_1B2
	{ 0x3EB4, 0x0000}, // DYNAMIC_SEQRAM_1B4
	{ 0x3EB6, 0x004D}, // DAC_LD_0_1
	{ 0x3EBC, 0x0086}, // DAC_LD_6_7
	{ 0x3EC0, 0x1E00}, // DAC_LD_10_11
	{ 0x3EC2, 0x000B}, // DAC_LD_12_13
	{ 0x3EC4, 0x3300}, // DAC_LD_14_15
	{ 0x3EC6, 0xEA44}, // DAC_LD_16_17
	{ 0x3EC8, 0x6F6F}, // DAC_LD_18_19
	{ 0x3ECA, 0x8F4A}, // DAC_LD_20_21
	{ 0x3ECC, 0x0706}, // DAC_LD_22_23
	{ 0x3ECE, 0x203B}, // DAC_LD_24_25
	{ 0x3ED0, 0x13F0}, // DAC_LD_26_27
	{ 0x3ED2, 0x9A3D}, // DAC_LD_28_29
	{ 0x3ED4, 0x862F}, // DAC_LD_30_31
	{ 0x3ED6, 0x4081}, // DAC_LD_32_33
	{ 0x3ED8, 0x4003}, // DAC_LD_34_35
	{ 0x3EDA, 0x9A80}, // DAC_LD_36_37
	{ 0x3EDC, 0xC000}, // DAC_LD_38_39
	{ 0x3EDE, 0xC103}, // DAC_LD_40_41
	{ 0x3426, 0x1600}, // AD_RESERVE_1_0
	{ 0x342A, 0x0038}, // PULSE_CONFIG
	{ 0x3F3E, 0x0001}, // ANALOG_CONTROL10
	{ 0x341A, 0x6051}, // AD_SH1_0
	{ 0x3420, 0x6051}, // AD_SH2_0
	{ 0x3EC2, 0x000A}, // DAC_LD_12_13
	{ 0x3ED8, 0x8003}, // DAC_LD_34_35
	{ 0x341A, 0x4735}, // AD_SH1_0
	{ 0x3420, 0x4735}, // AD_SH2_0
	{ 0x3426, 0x8A1A}, // AD_RESERVE_1_0
	{ 0x342A, 0x0018}, // PULSE_CONFIG
	{ 0x3F3E, 0x0000}, // ANALOG_CONTROL10
	{ 0x3F3E, 0x0000}, // ANALOG_CONTROL10
	{ 0x31B0, 0x0058}, // FRAME_PREAMBLE
	{ 0x31B2, 0x002C}, // LINE_PREAMBLE
	{ 0x31B4, 0x23D2}, // MIPI_TIMING_0
	{ 0x31B6, 0x13E9}, // MIPI_TIMING_1
	{ 0x31B8, 0x2413}, // MIPI_TIMING_2
	{ 0x31BA, 0x1C68}, // MIPI_TIMING_3
	{ 0x31BC, 0x860B}, // MIPI_TIMING_4
	{ 0x0112, 0x0A0A}, // CCP_DATA_FORMAT
	{ 0x0304, 0x0303}, // PRE_PLL_CLK_DIV
	{ 0x0306, 0x7359}, // PLL_MULTIPLIER
	{ 0x0302, 0x0001}, // VT_SYS_CLK_DIV
	{ 0x030A, 0x0001}, // OP_SYS_CLK_DIV
	{ 0x0300, 0x0005}, // VT_PIX_CLK_DIV
	{ 0x0308, 0x000A}, // OP_PIX_CLK_DIV
	{ 0x3016, 0x0101}, // ROW_SPEED
	{ 0x3004, 0x0154}, // X_ADDR_START_	340
	{ 0x3008, 0x08DB}, // X_ADDR_END_		2264
	{ 0x3002, 0x01B4}, // Y_ADDR_START_	436
	{ 0x3006, 0x05F3}, // Y_ADDR_END_		1523
	{ 0x3040, 0x0041}, // READ_MODE
	{ 0x3172, 0x0206}, // ANALOG_CONTROL2
	{ 0x317A, 0x416E}, // ANALOG_CONTROL6
	{ 0x3F3C, 0x0003}, // ANALOG_CONTROL9
	{ 0x034C, 0x0788}, // X_OUTPUT_SIZE
	{ 0x034E, 0x0440}, // Y_OUTPUT_SIZE
	{ 0x300C, 0x1178}, // LINE_LENGTH_PCK_
	{ 0x300A, 0x04E4}, // FRAME_LENGTH_LINES_
	{ 0x301A, 0x0210}, // RESET_REGISTER
	{ 0x301E, 0x00A8}, // DATA_PEDESTAL_
	{ 0x301A, 0x0218}, // RESET_REGISTER
	{ 0x30EE, 0x1136}, // DARK_CONTROL3
	{ 0x3F2C, 0x442E}, // GTH_THRES_RTN
	{ 0x301A, 0x0210}, // RESET_REGISTER
	{ 0x301E, 0x00AA}, // DATA_PEDESTAL_
	{ 0x301A, 0x0218}, // RESET_REGISTER
	{ 0x3120, 0x0005}, // GAIN_DITHER_CONTROL
	{ 0x300C, 0x05F0}, // LINE_LENGTH_PCK_
	{ 0x300A, 0x08DC}, // FRAME_LENGTH_LINES_
	////[]
	
	{ 0x301A, 0x021C}, // RESET_REGISTER
	{ REG_DLY,0x0032},	//Delay= 50
#elif 0
	{0x0103, 0x0001},   ///8bit
	{REG_DLY,0x0064},	//DELAY= 100
	//DELAY= 100
	{0x3042, 0x0000},  // DARK_CONTROL2
	{0x3044, 0x4580},  // DARK_CONTROL
	{0x30EE, 0x1140},  // DARK_CONTROL3
	{0x3120, 0x0001},  // GAIN_DITHER_CONTROL
	{0x3F2C, 0x772E},  // GTH_THRES_RTN
	{0x30D2, 0x0000},  // CRM_CONTROL
	{0x30D4, 0x0000},  // COLUMN_CORRECTION
	{0x30D6, 0x2FFF},  // COLUMN_CORRECTION2
	{0x30DA, 0x0FFF},  // COLUMN_CORRECTION_CLIP2
	{0x30DC, 0x0FFF},  // COLUMN_CORRECTION_CLIP3
	{0x30DE, 0x0000},  // COLUMN_GROUP_CORRECTION
	{0x31E0, 0x0781},  // PIX_DEF_ID
	{0x3180, 0x9434},  // FINE_DIG_CORRECTION_CONTROL
	{0x3172, 0x0206},  // ANALOG_CONTROL2
	{0x3F00, 0x0017},  // BM_T0
	{0x3F02, 0x02DD},  // BM_T1
	{0x3F04, 0x0020},  // NOISE_GAIN_THRESHOLD0
	{0x3F08, 0x0070},  // NOISE_GAIN_THRESHOLD2
	{0x3F0A, 0x0101},  // NOISE_FLOOR10
	{0x3F0C, 0x0302},  // NOISE_FLOOR32
	{0x3F1E, 0x0022},  // NOISE_COEF
	{0x3F1A, 0x01FF},  // CROSSFACTOR2
	{0x3F14, 0x0505},  // SINGLE_K_FACTOR2
	{0x3F44, 0x0707},  // COUPLE_K_FACTOR2
	{0x3F18, 0x01FF},  // CROSSFACTOR1
	{0x3F12, 0x0505},  // SINGLE_K_FACTOR1
	{0x3F42, 0x1511},  // COUPLE_K_FACTOR1
	{0x3F16, 0x01FF},  // CROSSFACTOR0
	{0x3F10, 0x0505},  // SINGLE_K_FACTOR0
	{0x3F40, 0x1511},  // COUPLE_K_FACTOR0
	{0x3D00, 0x043E},  // DYNAMIC_SEQRAM_00
	{0x3D02, 0x4760},  // DYNAMIC_SEQRAM_02
	{0x3D04, 0xFFFF},  // DYNAMIC_SEQRAM_04
	{0x3D06, 0xFFFF},  // DYNAMIC_SEQRAM_06
	{0x3D08, 0x8000},  // DYNAMIC_SEQRAM_08
	{0x3D0A, 0x0510},  // DYNAMIC_SEQRAM_0A
	{0x3D0C, 0xAF08},  // DYNAMIC_SEQRAM_0C
	{0x3D0E, 0x0252},  // DYNAMIC_SEQRAM_0E
	{0x3D10, 0x486F},  // DYNAMIC_SEQRAM_10
	{0x3D12, 0x5D5D},  // DYNAMIC_SEQRAM_12
	{0x3D14, 0x8056},  // DYNAMIC_SEQRAM_14
	{0x3D16, 0x8313},  // DYNAMIC_SEQRAM_16
	{0x3D18, 0x0087},  // DYNAMIC_SEQRAM_18
	{0x3D1A, 0x6A48},  // DYNAMIC_SEQRAM_1A
	{0x3D1C, 0x6982},  // DYNAMIC_SEQRAM_1C
	{0x3D1E, 0x0280},  // DYNAMIC_SEQRAM_1E
	{0x3D20, 0x8359},  // DYNAMIC_SEQRAM_20
	{0x3D22, 0x8D02},  // DYNAMIC_SEQRAM_22
	{0x3D24, 0x8020},  // DYNAMIC_SEQRAM_24
	{0x3D26, 0x4882},  // DYNAMIC_SEQRAM_26
	{0x3D28, 0x4269},  // DYNAMIC_SEQRAM_28
	{0x3D2A, 0x6A95},  // DYNAMIC_SEQRAM_2A
	{0x3D2C, 0x5988},  // DYNAMIC_SEQRAM_2C
	{0x3D2E, 0x5A83},  // DYNAMIC_SEQRAM_2E
	{0x3D30, 0x5885},  // DYNAMIC_SEQRAM_30
	{0x3D32, 0x6280},  // DYNAMIC_SEQRAM_32
	{0x3D34, 0x6289},  // DYNAMIC_SEQRAM_34
	{0x3D36, 0x6097},  // DYNAMIC_SEQRAM_36
	{0x3D38, 0x5782},  // DYNAMIC_SEQRAM_38
	{0x3D3A, 0x605C},  // DYNAMIC_SEQRAM_3A
	{0x3D3C, 0xBF18},  // DYNAMIC_SEQRAM_3C
	{0x3D3E, 0x0961},  // DYNAMIC_SEQRAM_3E
	{0x3D40, 0x5080},  // DYNAMIC_SEQRAM_40
	{0x3D42, 0x2090},  // DYNAMIC_SEQRAM_42
	{0x3D44, 0x4394},  // DYNAMIC_SEQRAM_44
	{0x3D46, 0x5F8A},  // DYNAMIC_SEQRAM_46
	{0x3D48, 0x5D5D},  // DYNAMIC_SEQRAM_48
	{0x3D4A, 0x8D43},  // DYNAMIC_SEQRAM_4A
	{0x3D4C, 0x8D63},  // DYNAMIC_SEQRAM_4C
	{0x3D4E, 0x8063},  // DYNAMIC_SEQRAM_4E
	{0x3D50, 0xA960},  // DYNAMIC_SEQRAM_50
	{0x3D52, 0x9757},  // DYNAMIC_SEQRAM_52
	{0x3D54, 0x8260},  // DYNAMIC_SEQRAM_54
	{0x3D56, 0x5CFF},  // DYNAMIC_SEQRAM_56
	{0x3D58, 0xBF10},  // DYNAMIC_SEQRAM_58
	{0x3D5A, 0x1681},  // DYNAMIC_SEQRAM_5A
	{0x3D5C, 0x0802},  // DYNAMIC_SEQRAM_5C
	{0x3D5E, 0x8000},  // DYNAMIC_SEQRAM_5E
	{0x3D60, 0x141C},  // DYNAMIC_SEQRAM_60
	{0x3D62, 0x6000},  // DYNAMIC_SEQRAM_62
	{0x3D64, 0x6022},  // DYNAMIC_SEQRAM_64
	{0x3D66, 0x4D80},  // DYNAMIC_SEQRAM_66
	{0x3D68, 0x5C97},  // DYNAMIC_SEQRAM_68
	{0x3D6A, 0x6A69},  // DYNAMIC_SEQRAM_6A
	{0x3D6C, 0xAC6F},  // DYNAMIC_SEQRAM_6C
	{0x3D6E, 0x4645},  // DYNAMIC_SEQRAM_6E
	{0x3D70, 0x4400},  // DYNAMIC_SEQRAM_70
	{0x3D72, 0x0513},  // DYNAMIC_SEQRAM_72
	{0x3D74, 0x8069},  // DYNAMIC_SEQRAM_74
	{0x3D76, 0x6AC6},  // DYNAMIC_SEQRAM_76
	{0x3D78, 0x5F95},  // DYNAMIC_SEQRAM_78
	{0x3D7A, 0x5F70},  // DYNAMIC_SEQRAM_7A
	{0x3D7C, 0x8040},  // DYNAMIC_SEQRAM_7C
	{0x3D7E, 0x4A81},  // DYNAMIC_SEQRAM_7E
	{0x3D80, 0x0300},  // DYNAMIC_SEQRAM_80
	{0x3D82, 0xE703},  // DYNAMIC_SEQRAM_82
	{0x3D84, 0x0088},  // DYNAMIC_SEQRAM_84
	{0x3D86, 0x4A83},  // DYNAMIC_SEQRAM_86
	{0x3D88, 0x40FF},  // DYNAMIC_SEQRAM_88
	{0x3D8A, 0xFFFF},  // DYNAMIC_SEQRAM_8A
	{0x3D8C, 0xFD70},  // DYNAMIC_SEQRAM_8C
	{0x3D8E, 0x8040},  // DYNAMIC_SEQRAM_8E
	{0x3D90, 0x4A85},  // DYNAMIC_SEQRAM_90
	{0x3D92, 0x4FA8},  // DYNAMIC_SEQRAM_92
	{0x3D94, 0x4F8C},  // DYNAMIC_SEQRAM_94
	{0x3D96, 0x0070},  // DYNAMIC_SEQRAM_96
	{0x3D98, 0xBE47},  // DYNAMIC_SEQRAM_98
	{0x3D9A, 0x8847},  // DYNAMIC_SEQRAM_9A
	{0x3D9C, 0xBC78},  // DYNAMIC_SEQRAM_9C
	{0x3D9E, 0x6B89},  // DYNAMIC_SEQRAM_9E
	{0x3DA0, 0x6A80},  // DYNAMIC_SEQRAM_A0
	{0x3DA2, 0x6986},  // DYNAMIC_SEQRAM_A2
	{0x3DA4, 0x6B8E},  // DYNAMIC_SEQRAM_A4
	{0x3DA6, 0x6B80},  // DYNAMIC_SEQRAM_A6
	{0x3DA8, 0x6980},  // DYNAMIC_SEQRAM_A8
	{0x3DAA, 0x6A88},  // DYNAMIC_SEQRAM_AA
	{0x3DAC, 0x7C9F},  // DYNAMIC_SEQRAM_AC
	{0x3DAE, 0x866B},  // DYNAMIC_SEQRAM_AE
	{0x3DB0, 0x8765},  // DYNAMIC_SEQRAM_B0
	{0x3DB2, 0x46FF},  // DYNAMIC_SEQRAM_B2
	{0x3DB4, 0xE365},  // DYNAMIC_SEQRAM_B4
	{0x3DB6, 0xA679},  // DYNAMIC_SEQRAM_B6
	{0x3DB8, 0x4A40},  // DYNAMIC_SEQRAM_B8
	{0x3DBA, 0x4580},  // DYNAMIC_SEQRAM_BA
	{0x3DBC, 0x44BC},  // DYNAMIC_SEQRAM_BC
	{0x3DBE, 0x7000},  // DYNAMIC_SEQRAM_BE
	{0x3DC0, 0x8040},  // DYNAMIC_SEQRAM_C0
	{0x3DC2, 0x0802},  // DYNAMIC_SEQRAM_C2
	{0x3DC4, 0x10EF},  // DYNAMIC_SEQRAM_C4
	{0x3DC6, 0x0104},  // DYNAMIC_SEQRAM_C6
	{0x3DC8, 0x3860},  // DYNAMIC_SEQRAM_C8
	{0x3DCA, 0x5D80},  // DYNAMIC_SEQRAM_CA
	{0x3DCC, 0x565D},  // DYNAMIC_SEQRAM_CC
	{0x3DCE, 0x8113},  // DYNAMIC_SEQRAM_CE
	{0x3DD0, 0x0086},  // DYNAMIC_SEQRAM_D0
	{0x3DD2, 0x4882},  // DYNAMIC_SEQRAM_D2
	{0x3DD4, 0x0280},  // DYNAMIC_SEQRAM_D4
	{0x3DD6, 0x8259},  // DYNAMIC_SEQRAM_D6
	{0x3DD8, 0x8A02},  // DYNAMIC_SEQRAM_D8
	{0x3DDA, 0x8020},  // DYNAMIC_SEQRAM_DA
	{0x3DDC, 0x4830},  // DYNAMIC_SEQRAM_DC
	{0x3DDE, 0x6080},  // DYNAMIC_SEQRAM_DE
	{0x3DE0, 0x4292},  // DYNAMIC_SEQRAM_E0
	{0x3DE2, 0x5986},  // DYNAMIC_SEQRAM_E2
	{0x3DE4, 0x5A82},  // DYNAMIC_SEQRAM_E4
	{0x3DE6, 0x5885},  // DYNAMIC_SEQRAM_E6
	{0x3DE8, 0x6280},  // DYNAMIC_SEQRAM_E8
	{0x3DEA, 0x6285},  // DYNAMIC_SEQRAM_EA
	{0x3DEC, 0x6092},  // DYNAMIC_SEQRAM_EC
	{0x3DEE, 0x5782},  // DYNAMIC_SEQRAM_EE
	{0x3DF0, 0x2110},  // DYNAMIC_SEQRAM_F0
	{0x3DF2, 0xFFB7},  // DYNAMIC_SEQRAM_F2
	{0x3DF4, 0x5793},  // DYNAMIC_SEQRAM_F4
	{0x3DF6, 0x6110},  // DYNAMIC_SEQRAM_F6
	{0x3DF8, 0x1980},  // DYNAMIC_SEQRAM_F8
	{0x3DFA, 0x2090},  // DYNAMIC_SEQRAM_FA
	{0x3DFC, 0x4394},  // DYNAMIC_SEQRAM_FC
	{0x3DFE, 0x5F83},  // DYNAMIC_SEQRAM_FE
	{0x3E00, 0x5D80},  // DYNAMIC_SEQRAM_100
	{0x3E02, 0x5D81},  // DYNAMIC_SEQRAM_102
	{0x3E04, 0x6380},  // DYNAMIC_SEQRAM_104
	{0x3E06, 0x6384},  // DYNAMIC_SEQRAM_106
	{0x3E08, 0x439A},  // DYNAMIC_SEQRAM_108
	{0x3E0A, 0x6091},  // DYNAMIC_SEQRAM_10A
	{0x3E0C, 0x5782},  // DYNAMIC_SEQRAM_10C
	{0x3E0E, 0x605C},  // DYNAMIC_SEQRAM_10E
	{0x3E10, 0xFFFF},  // DYNAMIC_SEQRAM_110
	{0x3E12, 0xFFFF},  // DYNAMIC_SEQRAM_112
	{0x3E14, 0xE510},  // DYNAMIC_SEQRAM_114
	{0x3E16, 0x1620},  // DYNAMIC_SEQRAM_116
	{0x3E18, 0x4808},  // DYNAMIC_SEQRAM_118
	{0x3E1A, 0x021C},  // DYNAMIC_SEQRAM_11A
	{0x3E1C, 0x6000},  // DYNAMIC_SEQRAM_11C
	{0x3E1E, 0x1400},  // DYNAMIC_SEQRAM_11E
	{0x3E20, 0x6022},  // DYNAMIC_SEQRAM_120
	{0x3E22, 0x0581},  // DYNAMIC_SEQRAM_122
	{0x3E24, 0x2090},  // DYNAMIC_SEQRAM_124
	{0x3E26, 0x8F6A},  // DYNAMIC_SEQRAM_126
	{0x3E28, 0x8069},  // DYNAMIC_SEQRAM_128
	{0x3E2A, 0x825F},  // DYNAMIC_SEQRAM_12A
	{0x3E2C, 0x9F6F},  // DYNAMIC_SEQRAM_12C
	{0x3E2E, 0x4645},  // DYNAMIC_SEQRAM_12E
	{0x3E30, 0x4400},  // DYNAMIC_SEQRAM_130
	{0x3E32, 0x0580},  // DYNAMIC_SEQRAM_132
	{0x3E34, 0x1380},  // DYNAMIC_SEQRAM_134
	{0x3E36, 0x696A},  // DYNAMIC_SEQRAM_136
	{0x3E38, 0x8070},  // DYNAMIC_SEQRAM_138
	{0x3E3A, 0x0000},  // DYNAMIC_SEQRAM_13A
	{0x3E3C, 0x0000},  // DYNAMIC_SEQRAM_13C
	{0x3E3E, 0x0000},  // DYNAMIC_SEQRAM_13E
	{0x3E40, 0x0000},  // DYNAMIC_SEQRAM_140
	{0x3E42, 0x0000},  // DYNAMIC_SEQRAM_142
	{0x3E44, 0x0000},  // DYNAMIC_SEQRAM_144
	{0x3E46, 0x0000},  // DYNAMIC_SEQRAM_146
	{0x3E48, 0x0000},  // DYNAMIC_SEQRAM_148
	{0x3E4A, 0x0000},  // DYNAMIC_SEQRAM_14A
	{0x3E4C, 0x0000},  // DYNAMIC_SEQRAM_14C
	{0x3E4E, 0x0000},  // DYNAMIC_SEQRAM_14E
	{0x3E50, 0x0000},  // DYNAMIC_SEQRAM_150
	{0x3E52, 0x0000},  // DYNAMIC_SEQRAM_152
	{0x3E54, 0x0000},  // DYNAMIC_SEQRAM_154
	{0x3E56, 0x0000},  // DYNAMIC_SEQRAM_156
	{0x3E58, 0x0000},  // DYNAMIC_SEQRAM_158
	{0x3E5A, 0x0000},  // DYNAMIC_SEQRAM_15A
	{0x3E5C, 0x0000},  // DYNAMIC_SEQRAM_15C
	{0x3E5E, 0x0000},  // DYNAMIC_SEQRAM_15E
	{0x3E60, 0x0000},  // DYNAMIC_SEQRAM_160
	{0x3E62, 0x0000},  // DYNAMIC_SEQRAM_162
	{0x3E64, 0x0000},  // DYNAMIC_SEQRAM_164
	{0x3E66, 0x0000},  // DYNAMIC_SEQRAM_166
	{0x3E68, 0x0000},  // DYNAMIC_SEQRAM_168
	{0x3E6A, 0x0000},  // DYNAMIC_SEQRAM_16A
	{0x3E6C, 0x0000},  // DYNAMIC_SEQRAM_16C
	{0x3E6E, 0x0000},  // DYNAMIC_SEQRAM_16E
	{0x3E70, 0x0000},  // DYNAMIC_SEQRAM_170
	{0x3E72, 0x0000},  // DYNAMIC_SEQRAM_172
	{0x3E74, 0x0000},  // DYNAMIC_SEQRAM_174
	{0x3E76, 0x0000},  // DYNAMIC_SEQRAM_176
	{0x3E78, 0x0000},  // DYNAMIC_SEQRAM_178
	{0x3E7A, 0x0000},  // DYNAMIC_SEQRAM_17A
	{0x3E7C, 0x0000},  // DYNAMIC_SEQRAM_17C
	{0x3E7E, 0x0000},  // DYNAMIC_SEQRAM_17E
	{0x3E80, 0x0000},  // DYNAMIC_SEQRAM_180
	{0x3E82, 0x0000},  // DYNAMIC_SEQRAM_182
	{0x3E84, 0x0000},  // DYNAMIC_SEQRAM_184
	{0x3E86, 0x0000},  // DYNAMIC_SEQRAM_186
	{0x3E88, 0x0000},  // DYNAMIC_SEQRAM_188
	{0x3E8A, 0x0000},  // DYNAMIC_SEQRAM_18A
	{0x3E8C, 0x0000},  // DYNAMIC_SEQRAM_18C
	{0x3E8E, 0x0000},  // DYNAMIC_SEQRAM_18E
	{0x3E90, 0x0000},  // DYNAMIC_SEQRAM_190
	{0x3E92, 0x0000},  // DYNAMIC_SEQRAM_192
	{0x3E94, 0x0000},  // DYNAMIC_SEQRAM_194
	{0x3E96, 0x0000},  // DYNAMIC_SEQRAM_196
	{0x3E98, 0x0000},  // DYNAMIC_SEQRAM_198
	{0x3E9A, 0x0000},  // DYNAMIC_SEQRAM_19A
	{0x3E9C, 0x0000},  // DYNAMIC_SEQRAM_19C
	{0x3E9E, 0x0000},  // DYNAMIC_SEQRAM_19E
	{0x3EA0, 0x0000},  // DYNAMIC_SEQRAM_1A0
	{0x3EA2, 0x0000},  // DYNAMIC_SEQRAM_1A2
	{0x3EA4, 0x0000},  // DYNAMIC_SEQRAM_1A4
	{0x3EA6, 0x0000},  // DYNAMIC_SEQRAM_1A6
	{0x3EA8, 0x0000},  // DYNAMIC_SEQRAM_1A8
	{0x3EAA, 0x0000},  // DYNAMIC_SEQRAM_1AA
	{0x3EAC, 0x0000},  // DYNAMIC_SEQRAM_1AC
	{0x3EAE, 0x0000},  // DYNAMIC_SEQRAM_1AE
	{0x3EB0, 0x0000},  // DYNAMIC_SEQRAM_1B0
	{0x3EB2, 0x0000},  // DYNAMIC_SEQRAM_1B2
	{0x3EB4, 0x0000},  // DYNAMIC_SEQRAM_1B4
	{0x3EB6, 0x004D},  // DAC_LD_0_1
	{0x3EBC, 0x0086},  // DAC_LD_6_7
	{0x3EC0, 0x1E00},  // DAC_LD_10_11
	{0x3EC2, 0x000B},  // DAC_LD_12_13
	{0x3EC4, 0x3300},  // DAC_LD_14_15
	{0x3EC6, 0xEA44},  // DAC_LD_16_17
	{0x3EC8, 0x6F6F},  // DAC_LD_18_19
	{0x3ECA, 0x8F4A},  // DAC_LD_20_21
	{0x3ECC, 0x0706},  // DAC_LD_22_23
	{0x3ECE, 0x203B},  // DAC_LD_24_25
	{0x3ED0, 0x13F0},  // DAC_LD_26_27
	{0x3ED2, 0x9A3D},  // DAC_LD_28_29
	{0x3ED4, 0x862F},  // DAC_LD_30_31
	{0x3ED6, 0x4081},  // DAC_LD_32_33
	{0x3ED8, 0x4003},  // DAC_LD_34_35
	{0x3EDA, 0x9A80},  // DAC_LD_36_37
	{0x3EDC, 0xC000},  // DAC_LD_38_39
	{0x3EDE, 0xC103},  // DAC_LD_40_41
	{0x3426, 0x1600},  // AD_RESERVE_1_0
	{0x342A, 0x0038},  // PULSE_CONFIG
	{0x3F3E, 0x0001},  // ANALOG_CONTROL10
	{0x341A, 0x6051},  // AD_SH1_0
	{0x3420, 0x6051},  // AD_SH2_0
	{0x3EC2, 0x000A},  // DAC_LD_12_13
	{0x3ED8, 0x8003},  // DAC_LD_34_35
	{0x341A, 0x4735},  // AD_SH1_0
	{0x3420, 0x4735},  // AD_SH2_0
	{0x3426, 0x8A1A},  // AD_RESERVE_1_0
	{0x342A, 0x0018},  // PULSE_CONFIG
	{0x3F3E, 0x0000},  // ANALOG_CONTROL10
	{0x0300, 0x0005},  // VT_PIX_CLK_DIV
	{0x0302, 0x0001},  // VT_SYS_CLK_DIV
	{0x0304, 0x0303},  // PRE_PLL_CLK_DIV
	{0x0306, 0x8164},  // PLL_MULTIPLIER },  //
	{0x0308, 0x000A},  // OP_PIX_CLK_DIV
	{0x030A, 0x0001},  // OP_SYS_CLK_DIV
	//DELAY= 1
	{0x3004, 0x0004},  // X_ADDR_START_
	{0x3008, 0x0A2B},  // X_ADDR_END_
	{0x3002, 0x0004},  // Y_ADDR_START_
	{0x3006, 0x07A3},  // Y_ADDR_END_
	{0x034C, 0x0A28},  // X_OUTPUT_SIZE
	{0x034E, 0x07A0},  // Y_OUTPUT_SIZE
	{0x3400, 0x0120},  // T1_T2_INTERVAL
	{0x303E, 0x0000},  // READ_STYLE
	{0x3040, 0x0041},  // READ_MODE
	{0x317A, 0x416E},  // ANALOG_CONTROL6
	{0x300C, 0x0BC8},  // LINE_LENGTH_PCK_
	{0x300A, 0x11D0},  // FRAME_LENGTH_LINES },  //11d0
	{0x3012, 0x08E6},  // COARSE_INTEGRATION_TIME_
	{0x3088, 0x0239},  // COARSE_INTEGRATION2_TIME
	{0x0112, 0x0A0A},  // CCP_DATA_FORMAT
	{0x31AE, 0x0204},  // SERIAL_FORMAT
	{0x0112, 0x0A0A},  // CCP_DATA_FORMAT
	{0x303E, 0x0000},  // READ_STYLE
	{0x0110, 0x0000},  // CCP2_CHANNEL_MODE
	{0x31B0, 0x0058},  // FRAME_PREAMBLE
	{0x31B2, 0x002C},  // LINE_PREAMBLE
	{0x31B4, 0x23D2},  // MIPI_TIMING_0
	{0x31B6, 0x13E9},  // MIPI_TIMING_1
	{0x31B8, 0x2413},  // MIPI_TIMING_2
	{0x31BA, 0x1C68},  // MIPI_TIMING_3
	{0x31BC, 0x860B},  // MIPI_TIMING_4
	////[]


	{0x301A, 0x021C},  // RESET_REGISTER
#elif 0
	{0x301A, 0x0001}, 
	{REG_DLY,0x00C8}, 
	{0x3042, 0x0004},
	{0x3044, 0x4580},
	{0x30EE, 0x1136},
	{0x3120, 0x0001},
	{0x3F2C, 0x442E},
	{0x30D2, 0x0000},
	{0x30D4, 0x0000},
	{0x30D6, 0x2FFF},
	{0x30DA, 0x0FFF},
	{0x30DC, 0x0FFF},
	{0x30DE, 0x0000},
	{0x31E0, 0x0781},
	{0x3180, 0x9434},
	{0x3172, 0x0206},
	{0x3F00, 0x0017},
	{0x3F02, 0x02DD},
	{0x3F04, 0x0020},
	{0x3F08, 0x0070},
	{0x3F0A, 0x0101},
	{0x3F0C, 0x0302},
	{0x3F1E, 0x0022},
	{0x3F1A, 0x01FF},
	{0x3F14, 0x0505},
	{0x3F44, 0x0707},
	{0x3F18, 0x01FF},
	{0x3F12, 0x0505},
	{0x3F42, 0x1511},
	{0x3F16, 0x01FF},
	{0x3F10, 0x0505},
	{0x3F40, 0x1511},
	{0x3D00, 0x043E},
	{0x3D02, 0x4760},
	{0x3D04, 0xFFFF},
	{0x3D06, 0xFFFF},
	{0x3D08, 0x8000},
	{0x3D0A, 0x0510},
	{0x3D0C, 0xAF08},
	{0x3D0E, 0x0252},
	{0x3D10, 0x486F},
	{0x3D12, 0x5D5D},
	{0x3D14, 0x8056},
	{0x3D16, 0x8313},
	{0x3D18, 0x0087},
	{0x3D1A, 0x6A48},
	{0x3D1C, 0x6982},
	{0x3D1E, 0x0280},
	{0x3D20, 0x8359},
	{0x3D22, 0x8D02},
	{0x3D24, 0x8020},
	{0x3D26, 0x4882},
	{0x3D28, 0x4269},
	{0x3D2A, 0x6A95},
	{0x3D2C, 0x5988},
	{0x3D2E, 0x5A83},
	{0x3D30, 0x5885},
	{0x3D32, 0x6280},
	{0x3D34, 0x6289},
	{0x3D36, 0x6097},
	{0x3D38, 0x5782},
	{0x3D3A, 0x605C},
	{0x3D3C, 0xBF18},
	{0x3D3E, 0x0961},
	{0x3D40, 0x5080},
	{0x3D42, 0x2090},
	{0x3D44, 0x4394},
	{0x3D46, 0x5F8A},
	{0x3D48, 0x5D5D},
	{0x3D4A, 0x8D43},
	{0x3D4C, 0x8D63},
	{0x3D4E, 0x8063},
	{0x3D50, 0xA960},
	{0x3D52, 0x9757},
	{0x3D54, 0x8260},
	{0x3D56, 0x5CFF},
	{0x3D58, 0xBF10},
	{0x3D5A, 0x1681},
	{0x3D5C, 0x0802},
	{0x3D5E, 0x8000},
	{0x3D60, 0x141C},
	{0x3D62, 0x6000},
	{0x3D64, 0x6022},
	{0x3D66, 0x4D80},
	{0x3D68, 0x5C97},
	{0x3D6A, 0x6A69},
	{0x3D6C, 0xAC6F},
	{0x3D6E, 0x4645},
	{0x3D70, 0x4400},
	{0x3D72, 0x0513},
	{0x3D74, 0x8069},
	{0x3D76, 0x6AC6},
	{0x3D78, 0x5F95},
	{0x3D7A, 0x5F70},
	{0x3D7C, 0x8040},
	{0x3D7E, 0x4A81},
	{0x3D80, 0x0300},
	{0x3D82, 0xE703},
	{0x3D84, 0x0088},
	{0x3D86, 0x4A83},
	{0x3D88, 0x40FF},
	{0x3D8A, 0xFFFF},
	{0x3D8C, 0xFD70},
	{0x3D8E, 0x8040},
	{0x3D90, 0x4A85},
	{0x3D92, 0x4FA8},
	{0x3D94, 0x4F8C},
	{0x3D96, 0x0070},
	{0x3D98, 0xBE47},
	{0x3D9A, 0x8847},
	{0x3D9C, 0xBC78},
	{0x3D9E, 0x6B89},
	{0x3DA0, 0x6A80},
	{0x3DA2, 0x6986},
	{0x3DA4, 0x6B8E},
	{0x3DA6, 0x6B80},
	{0x3DA8, 0x6980},
	{0x3DAA, 0x6A88},
	{0x3DAC, 0x7C9F},
	{0x3DAE, 0x866B},
	{0x3DB0, 0x8765},
	{0x3DB2, 0x46FF},
	{0x3DB4, 0xE365},
	{0x3DB6, 0xA679},
	{0x3DB8, 0x4A40},
	{0x3DBA, 0x4580},
	{0x3DBC, 0x44BC},
	{0x3DBE, 0x7000},
	{0x3DC0, 0x8040},
	{0x3DC2, 0x0802},
	{0x3DC4, 0x10EF},
	{0x3DC6, 0x0104},
	{0x3DC8, 0x3860},
	{0x3DCA, 0x5D5D},
	{0x3DCC, 0x5682},
	{0x3DCE, 0x1300},
	{0x3DD0, 0x8648},
	{0x3DD2, 0x8202},
	{0x3DD4, 0x8082},
	{0x3DD6, 0x598A},
	{0x3DD8, 0x0280},
	{0x3DDA, 0x2048},
	{0x3DDC, 0x3060},
	{0x3DDE, 0x8042},
	{0x3DE0, 0x9259},
	{0x3DE2, 0x865A},
	{0x3DE4, 0x8258},
	{0x3DE6, 0x8562},
	{0x3DE8, 0x8062},
	{0x3DEA, 0x8560},
	{0x3DEC, 0x9257},
	{0x3DEE, 0x8221},
	{0x3DF0, 0x10FF},
	{0x3DF2, 0xB757},
	{0x3DF4, 0x9361},
	{0x3DF6, 0x1019},
	{0x3DF8, 0x8020},
	{0x3DFA, 0x9043},
	{0x3DFC, 0x945F},
	{0x3DFE, 0x835D},
	{0x3E00, 0x805D},
	{0x3E02, 0x8163},
	{0x3E04, 0x8063},
	{0x3E06, 0x8443},
	{0x3E08, 0x9A60},
	{0x3E0A, 0x9157},
	{0x3E0C, 0x8260},
	{0x3E0E, 0x5CFF},
	{0x3E10, 0xFFFF},
	{0x3E12, 0xFFE5},
	{0x3E14, 0x1016},
	{0x3E16, 0x2048},
	{0x3E18, 0x0802},
	{0x3E1A, 0x1C60},
	{0x3E1C, 0x0014},
	{0x3E1E, 0x0060},
	{0x3E20, 0x2205},
	{0x3E22, 0x8120},
	{0x3E24, 0x908F},
	{0x3E26, 0x6A80},
	{0x3E28, 0x6982},
	{0x3E2A, 0x5F9F},
	{0x3E2C, 0x6F46},
	{0x3E2E, 0x4544},
	{0x3E30, 0x0005},
	{0x3E32, 0x8013},
	{0x3E34, 0x8069},
	{0x3E36, 0x6A80},
	{0x3E38, 0x7000},
	{0x3E3A, 0x0000},
	{0x3E3C, 0x0000},
	{0x3E3E, 0x0000},
	{0x3E40, 0x0000},
	{0x3E42, 0x0000},
	{0x3E44, 0x0000},
	{0x3E46, 0x0000},
	{0x3E48, 0x0000},
	{0x3E4A, 0x0000},
	{0x3E4C, 0x0000},
	{0x3E4E, 0x0000},
	{0x3E50, 0x0000},
	{0x3E52, 0x0000},
	{0x3E54, 0x0000},
	{0x3E56, 0x0000},
	{0x3E58, 0x0000},
	{0x3E5A, 0x0000},
	{0x3E5C, 0x0000},
	{0x3E5E, 0x0000},
	{0x3E60, 0x0000},
	{0x3E62, 0x0000},
	{0x3E64, 0x0000},
	{0x3E66, 0x0000},
	{0x3E68, 0x0000},
	{0x3E6A, 0x0000},
	{0x3E6C, 0x0000},
	{0x3E6E, 0x0000},
	{0x3E70, 0x0000},
	{0x3E72, 0x0000},
	{0x3E74, 0x0000},
	{0x3E76, 0x0000},
	{0x3E78, 0x0000},
	{0x3E7A, 0x0000},
	{0x3E7C, 0x0000},
	{0x3E7E, 0x0000},
	{0x3E80, 0x0000},
	{0x3E82, 0x0000},
	{0x3E84, 0x0000},
	{0x3E86, 0x0000},
	{0x3E88, 0x0000},
	{0x3E8A, 0x0000},
	{0x3E8C, 0x0000},
	{0x3E8E, 0x0000},
	{0x3E90, 0x0000},
	{0x3E92, 0x0000},
	{0x3E94, 0x0000},
	{0x3E96, 0x0000},
	{0x3E98, 0x0000},
	{0x3E9A, 0x0000},
	{0x3E9C, 0x0000},
	{0x3E9E, 0x0000},
	{0x3EA0, 0x0000},
	{0x3EA2, 0x0000},
	{0x3EA4, 0x0000},
	{0x3EA6, 0x0000},
	{0x3EA8, 0x0000},
	{0x3EAA, 0x0000},
	{0x3EAC, 0x0000},
	{0x3EAE, 0x0000},
	{0x3EB0, 0x0000},
	{0x3EB2, 0x0000},
	{0x3EB4, 0x0000},
	{0x3EB6, 0x004C},
	{0x3EBA, 0xAAAA},
	{0x3EBC, 0x0086},
	{0x3EC0, 0x1E00},
	{0x3EC2, 0x000B},
	{0x3EC4, 0x3300},
	{0x3EC6, 0xEA44},
	{0x3EC8, 0x6F6F},
	{0x3ECA, 0x2F4A},
	{0x3ECC, 0x0506},
	{0x3ECE, 0x203B},
	{0x3ED0, 0x13F0},
	{0x3ED2, 0x9A3D},
	{0x3ED4, 0x862F},
	{0x3ED6, 0x4081},
	{0x3ED8, 0x4003},
	{0x3EDA, 0x9A80},
	{0x3EDC, 0xC000},
	{0x3EDE, 0xC103},
	{0x3426, 0x1600},
	{0x342A, 0x0038},
	{0x3F3E, 0x0001},
	{0x341A, 0x6051},
	{0x3420, 0x6051},
	{0x3EC2, 0x000A},
	{0x3ED8, 0x8003},
	{0x341A, 0x4735},
	{0x3420, 0x4735},
	{0x3426, 0x8A1A},
	{0x342A, 0x0018},
	{0x3ED2, 0xA53D},
	{0x3EDA, 0xA580},
	{0x3EBA, 0xAAAD},
	{0x3EB6, 0x004C},
	{0x3F3E, 0x0000},
	{0x31B0, 0x0041},
	{0x31B2, 0x0023},
	{0x31B4, 0x124E},
	{0x31B6, 0x1246},
	{0x31B8, 0x1412},
	{0x31BA, 0x1441},
	{0x31BC, 0x8406},
	{0x0112, 0x0A0A},
	{0x0304, 0x0303},
	{0x0306, 0x4434},
	{0x0302, 0x0001},
	{0x030A, 0x0001},
	{0x0300, 0x0005},
	{0x0308, 0x000A},
	{0x3016, 0x0101},
	{0x3004, 0x0008},
	{0x3008, 0x0A27},
	{0x3002, 0x0008},
	{0x3006, 0x079F},
	{0x3040, 0x0041},
	{0x317A, 0x416E},
	{0x3F3C, 0x0003},
	{0x034C, 0x0A20},
	{0x034E, 0x0798},
	{0x301A, 0x0210},
	{0x301E, 0x00A8},
	{0x301A, 0x0218},
	{0x30EE, 0x1136},
	{0x3F2C, 0x442E},
	{0x301A, 0x0210},
	{0x301E, 0x00AA},	//data pedestal
	{0x301A, 0x0218},	//reset_register
	{0x3120, 0x0005},	//gain_dither_control 
	{0x300C, 0x0BE0},	//line_length_pck
	{0x300A, 0x0A7C},	//frame_length_lines
	{0x3012, 0x0A70},	//coarse integration time
	{0x301A, 0x021C}, //reset_register   stream mode
	{REG_DLY,0x000A},
#else
	//[1920*1080 30fps 24Mhz MIPI 4lane 10bit]
	{0x0103, 0x01},
	{REG_DLY,0x64},	//DELAY= 100
	{REG_DLY,0x64},	//DELAY= 100
	{0x3042, 0x0004},  // DARK_CONTROL2
	{0x3044, 0x4580},  // DARK_CONTROL
	{0x30EE, 0x1136},  // DARK_CONTROL3
	{0x3120, 0x0001},  // DITHER_CONTROL
	{0x3F2C, 0x442E},  // GTH_THRES_RTN
	{0x30D2, 0x0000},  // CRM_CONTROL
	{0x30D4, 0x0000},  // COLUMN_CORRECTION
	{0x30D6, 0x2FFF},  // COLUMN_CORRECTION2
	{0x30DA, 0x0FFF},  // COLUMN_CORRECTION_CLIP2
	{0x30DC, 0x0FFF},  // COLUMN_CORRECTION_CLIP3
	{0x30DE, 0x0000},  // COLUMN_GROUP_CORRECTION
	{0x31E0, 0x0781},  // PIX_DEF_ID
	{0x3180, 0x9434},  // FINE_DIG_CORRECTION_CONTROL
	{0x3172, 0x0206},  // ANALOG_CONTROL2
	{0x3F00, 0x0017},  // BM_T0
	{0x3F02, 0x02DD},  // BM_T1
	{0x3F04, 0x0020},  // NOISE_GAIN_THRESHOLD0
	{0x3F08, 0x0070},  // NOISE_GAIN_THRESHOLD2
	{0x3F0A, 0x0101},  // NOISE_FLOOR10
	{0x3F0C, 0x0302},  // NOISE_FLOOR32
	{0x3F1E, 0x0022},  // NOISE_COEF
	{0x3F1A, 0x01FF},  // CROSSFACTOR2
	{0x3F14, 0x0505},  // SINGLE_K_FACTOR2
	{0x3F44, 0x0707},  // COUPLE_K_FACTOR2
	{0x3F18, 0x01FF},  // CROSSFACTOR1
	{0x3F12, 0x0505},  // SINGLE_K_FACTOR1
	{0x3F42, 0x1511},  // COUPLE_K_FACTOR1
	{0x3F16, 0x01FF},  // CROSSFACTOR0
	{0x3F10, 0x0505},  // SINGLE_K_FACTOR0
	{0x3F40, 0x1511},  // COUPLE_K_FACTOR0
	{0x3D00, 0x043E},  // DYNAMIC_SEQRAM_00
	{0x3D02, 0x4760},  // DYNAMIC_SEQRAM_02
	{0x3D04, 0xFFFF},  // DYNAMIC_SEQRAM_04
	{0x3D06, 0xFFFF},  // DYNAMIC_SEQRAM_06
	{0x3D08, 0x8000},  // DYNAMIC_SEQRAM_08
	{0x3D0A, 0x0510},  // DYNAMIC_SEQRAM_0A
	{0x3D0C, 0xAF08},  // DYNAMIC_SEQRAM_0C
	{0x3D0E, 0x0252},  // DYNAMIC_SEQRAM_0E
	{0x3D10, 0x486F},  // DYNAMIC_SEQRAM_10
	{0x3D12, 0x5D5D},  // DYNAMIC_SEQRAM_12
	{0x3D14, 0x8056},  // DYNAMIC_SEQRAM_14
	{0x3D16, 0x8313},  // DYNAMIC_SEQRAM_16
	{0x3D18, 0x0087},  // DYNAMIC_SEQRAM_18
	{0x3D1A, 0x6A48},  // DYNAMIC_SEQRAM_1A
	{0x3D1C, 0x6982},  // DYNAMIC_SEQRAM_1C
	{0x3D1E, 0x0280},  // DYNAMIC_SEQRAM_1E
	{0x3D20, 0x8359},  // DYNAMIC_SEQRAM_20
	{0x3D22, 0x8D02},  // DYNAMIC_SEQRAM_22
	{0x3D24, 0x8020},  // DYNAMIC_SEQRAM_24
	{0x3D26, 0x4882},  // DYNAMIC_SEQRAM_26
	{0x3D28, 0x4269},  // DYNAMIC_SEQRAM_28
	{0x3D2A, 0x6A95},  // DYNAMIC_SEQRAM_2A
	{0x3D2C, 0x5988},  // DYNAMIC_SEQRAM_2C
	{0x3D2E, 0x5A83},  // DYNAMIC_SEQRAM_2E
	{0x3D30, 0x5885},  // DYNAMIC_SEQRAM_30
	{0x3D32, 0x6280},  // DYNAMIC_SEQRAM_32
	{0x3D34, 0x6289},  // DYNAMIC_SEQRAM_34
	{0x3D36, 0x6097},  // DYNAMIC_SEQRAM_36
	{0x3D38, 0x5782},  // DYNAMIC_SEQRAM_38
	{0x3D3A, 0x605C},  // DYNAMIC_SEQRAM_3A
	{0x3D3C, 0xBF18},  // DYNAMIC_SEQRAM_3C
	{0x3D3E, 0x0961},  // DYNAMIC_SEQRAM_3E
	{0x3D40, 0x5080},  // DYNAMIC_SEQRAM_40
	{0x3D42, 0x2090},  // DYNAMIC_SEQRAM_42
	{0x3D44, 0x4394},  // DYNAMIC_SEQRAM_44
	{0x3D46, 0x5F8A},  // DYNAMIC_SEQRAM_46
	{0x3D48, 0x5D5D},  // DYNAMIC_SEQRAM_48
	{0x3D4A, 0x8D43},  // DYNAMIC_SEQRAM_4A
	{0x3D4C, 0x8D63},  // DYNAMIC_SEQRAM_4C
	{0x3D4E, 0x8063},  // DYNAMIC_SEQRAM_4E
	{0x3D50, 0xA960},  // DYNAMIC_SEQRAM_50
	{0x3D52, 0x9757},  // DYNAMIC_SEQRAM_52
	{0x3D54, 0x8260},  // DYNAMIC_SEQRAM_54
	{0x3D56, 0x5CFF},  // DYNAMIC_SEQRAM_56
	{0x3D58, 0xBF10},  // DYNAMIC_SEQRAM_58
	{0x3D5A, 0x1681},  // DYNAMIC_SEQRAM_5A
	{0x3D5C, 0x0802},  // DYNAMIC_SEQRAM_5C
	{0x3D5E, 0x8000},  // DYNAMIC_SEQRAM_5E
	{0x3D60, 0x141C},  // DYNAMIC_SEQRAM_60
	{0x3D62, 0x6000},  // DYNAMIC_SEQRAM_62
	{0x3D64, 0x6022},  // DYNAMIC_SEQRAM_64
	{0x3D66, 0x4D80},  // DYNAMIC_SEQRAM_66
	{0x3D68, 0x5C97},  // DYNAMIC_SEQRAM_68
	{0x3D6A, 0x6A69},  // DYNAMIC_SEQRAM_6A
	{0x3D6C, 0xAC6F},  // DYNAMIC_SEQRAM_6C
	{0x3D6E, 0x4645},  // DYNAMIC_SEQRAM_6E
	{0x3D70, 0x4400},  // DYNAMIC_SEQRAM_70
	{0x3D72, 0x0513},  // DYNAMIC_SEQRAM_72
	{0x3D74, 0x8069},  // DYNAMIC_SEQRAM_74
	{0x3D76, 0x6AC6},  // DYNAMIC_SEQRAM_76
	{0x3D78, 0x5F95},  // DYNAMIC_SEQRAM_78
	{0x3D7A, 0x5F70},  // DYNAMIC_SEQRAM_7A
	{0x3D7C, 0x8040},  // DYNAMIC_SEQRAM_7C
	{0x3D7E, 0x4A81},  // DYNAMIC_SEQRAM_7E
	{0x3D80, 0x0300},  // DYNAMIC_SEQRAM_80
	{0x3D82, 0xE703},  // DYNAMIC_SEQRAM_82
	{0x3D84, 0x0088},  // DYNAMIC_SEQRAM_84
	{0x3D86, 0x4A83},  // DYNAMIC_SEQRAM_86
	{0x3D88, 0x40FF},  // DYNAMIC_SEQRAM_88
	{0x3D8A, 0xFFFF},  // DYNAMIC_SEQRAM_8A
	{0x3D8C, 0xFD70},  // DYNAMIC_SEQRAM_8C
	{0x3D8E, 0x8040},  // DYNAMIC_SEQRAM_8E
	{0x3D90, 0x4A85},  // DYNAMIC_SEQRAM_90
	{0x3D92, 0x4FA8},  // DYNAMIC_SEQRAM_92
	{0x3D94, 0x4F8C},  // DYNAMIC_SEQRAM_94
	{0x3D96, 0x0070},  // DYNAMIC_SEQRAM_96
	{0x3D98, 0xBE47},  // DYNAMIC_SEQRAM_98
	{0x3D9A, 0x8847},  // DYNAMIC_SEQRAM_9A
	{0x3D9C, 0xBC78},  // DYNAMIC_SEQRAM_9C
	{0x3D9E, 0x6B89},  // DYNAMIC_SEQRAM_9E
	{0x3DA0, 0x6A80},  // DYNAMIC_SEQRAM_A0
	{0x3DA2, 0x6986},  // DYNAMIC_SEQRAM_A2
	{0x3DA4, 0x6B8E},  // DYNAMIC_SEQRAM_A4
	{0x3DA6, 0x6B80},  // DYNAMIC_SEQRAM_A6
	{0x3DA8, 0x6980},  // DYNAMIC_SEQRAM_A8
	{0x3DAA, 0x6A88},  // DYNAMIC_SEQRAM_AA
	{0x3DAC, 0x7C9F},  // DYNAMIC_SEQRAM_AC
	{0x3DAE, 0x866B},  // DYNAMIC_SEQRAM_AE
	{0x3DB0, 0x8765},  // DYNAMIC_SEQRAM_B0
	{0x3DB2, 0x46FF},  // DYNAMIC_SEQRAM_B2
	{0x3DB4, 0xE365},  // DYNAMIC_SEQRAM_B4
	{0x3DB6, 0xA679},  // DYNAMIC_SEQRAM_B6
	{0x3DB8, 0x4A40},  // DYNAMIC_SEQRAM_B8
	{0x3DBA, 0x4580},  // DYNAMIC_SEQRAM_BA
	{0x3DBC, 0x44BC},  // DYNAMIC_SEQRAM_BC
	{0x3DBE, 0x7000},  // DYNAMIC_SEQRAM_BE
	{0x3DC0, 0x8040},  // DYNAMIC_SEQRAM_C0
	{0x3DC2, 0x0802},  // DYNAMIC_SEQRAM_C2
	{0x3DC4, 0x10EF},  // DYNAMIC_SEQRAM_C4
	{0x3DC6, 0x0104},  // DYNAMIC_SEQRAM_C6
	{0x3DC8, 0x3860},  // DYNAMIC_SEQRAM_C8
	{0x3DCA, 0x5D5D},  // DYNAMIC_SEQRAM_CA
	{0x3DCC, 0x5682},  // DYNAMIC_SEQRAM_CC
	{0x3DCE, 0x1300},  // DYNAMIC_SEQRAM_CE
	{0x3DD0, 0x8648},  // DYNAMIC_SEQRAM_D0
	{0x3DD2, 0x8202},  // DYNAMIC_SEQRAM_D2
	{0x3DD4, 0x8082},  // DYNAMIC_SEQRAM_D4
	{0x3DD6, 0x598A},  // DYNAMIC_SEQRAM_D6
	{0x3DD8, 0x0280},  // DYNAMIC_SEQRAM_D8
	{0x3DDA, 0x2048},  // DYNAMIC_SEQRAM_DA
	{0x3DDC, 0x3060},  // DYNAMIC_SEQRAM_DC
	{0x3DDE, 0x8042},  // DYNAMIC_SEQRAM_DE
	{0x3DE0, 0x9259},  // DYNAMIC_SEQRAM_E0
	{0x3DE2, 0x865A},  // DYNAMIC_SEQRAM_E2
	{0x3DE4, 0x8258},  // DYNAMIC_SEQRAM_E4
	{0x3DE6, 0x8562},  // DYNAMIC_SEQRAM_E6
	{0x3DE8, 0x8062},  // DYNAMIC_SEQRAM_E8
	{0x3DEA, 0x8560},  // DYNAMIC_SEQRAM_EA
	{0x3DEC, 0x9257},  // DYNAMIC_SEQRAM_EC
	{0x3DEE, 0x8221},  // DYNAMIC_SEQRAM_EE
	{0x3DF0, 0x10FF},  // DYNAMIC_SEQRAM_F0
	{0x3DF2, 0xB757},  // DYNAMIC_SEQRAM_F2
	{0x3DF4, 0x9361},  // DYNAMIC_SEQRAM_F4
	{0x3DF6, 0x1019},  // DYNAMIC_SEQRAM_F6
	{0x3DF8, 0x8020},  // DYNAMIC_SEQRAM_F8
	{0x3DFA, 0x9043},  // DYNAMIC_SEQRAM_FA
	{0x3DFC, 0x945F},  // DYNAMIC_SEQRAM_FC
	{0x3DFE, 0x835D},  // DYNAMIC_SEQRAM_FE
	{0x3E00, 0x805D},  // DYNAMIC_SEQRAM_100
	{0x3E02, 0x8163},  // DYNAMIC_SEQRAM_102
	{0x3E04, 0x8063},  // DYNAMIC_SEQRAM_104
	{0x3E06, 0x8443},  // DYNAMIC_SEQRAM_106
	{0x3E08, 0x9A60},  // DYNAMIC_SEQRAM_108
	{0x3E0A, 0x9157},  // DYNAMIC_SEQRAM_10A
	{0x3E0C, 0x8260},  // DYNAMIC_SEQRAM_10C
	{0x3E0E, 0x5CFF},  // DYNAMIC_SEQRAM_10E
	{0x3E10, 0xFFFF},  // DYNAMIC_SEQRAM_110
	{0x3E12, 0xFFE5},  // DYNAMIC_SEQRAM_112
	{0x3E14, 0x1016},  // DYNAMIC_SEQRAM_114
	{0x3E16, 0x2048},  // DYNAMIC_SEQRAM_116
	{0x3E18, 0x0802},  // DYNAMIC_SEQRAM_118
	{0x3E1A, 0x1C60},  // DYNAMIC_SEQRAM_11A
	{0x3E1C, 0x0014},  // DYNAMIC_SEQRAM_11C
	{0x3E1E, 0x0060},  // DYNAMIC_SEQRAM_11E
	{0x3E20, 0x2205},  // DYNAMIC_SEQRAM_120
	{0x3E22, 0x8120},  // DYNAMIC_SEQRAM_122
	{0x3E24, 0x908F},  // DYNAMIC_SEQRAM_124
	{0x3E26, 0x6A80},  // DYNAMIC_SEQRAM_126
	{0x3E28, 0x6982},  // DYNAMIC_SEQRAM_128
	{0x3E2A, 0x5F9F},  // DYNAMIC_SEQRAM_12A
	{0x3E2C, 0x6F46},  // DYNAMIC_SEQRAM_12C
	{0x3E2E, 0x4544},  // DYNAMIC_SEQRAM_12E
	{0x3E30, 0x0005},  // DYNAMIC_SEQRAM_130
	{0x3E32, 0x8013},  // DYNAMIC_SEQRAM_132
	{0x3E34, 0x8069},  // DYNAMIC_SEQRAM_134
	{0x3E36, 0x6A80},  // DYNAMIC_SEQRAM_136
	{0x3E38, 0x7000},  // DYNAMIC_SEQRAM_138
	{0x3E3A, 0x0000},  // DYNAMIC_SEQRAM_13A
	{0x3E3C, 0x0000},  // DYNAMIC_SEQRAM_13C
	{0x3E3E, 0x0000},  // DYNAMIC_SEQRAM_13E
	{0x3E40, 0x0000},  // DYNAMIC_SEQRAM_140
	{0x3E42, 0x0000},  // DYNAMIC_SEQRAM_142
	{0x3E44, 0x0000},  // DYNAMIC_SEQRAM_144
	{0x3E46, 0x0000},  // DYNAMIC_SEQRAM_146
	{0x3E48, 0x0000},  // DYNAMIC_SEQRAM_148
	{0x3E4A, 0x0000},  // DYNAMIC_SEQRAM_14A
	{0x3E4C, 0x0000},  // DYNAMIC_SEQRAM_14C
	{0x3E4E, 0x0000},  // DYNAMIC_SEQRAM_14E
	{0x3E50, 0x0000},  // DYNAMIC_SEQRAM_150
	{0x3E52, 0x0000},  // DYNAMIC_SEQRAM_152
	{0x3E54, 0x0000},  // DYNAMIC_SEQRAM_154
	{0x3E56, 0x0000},  // DYNAMIC_SEQRAM_156
	{0x3E58, 0x0000},  // DYNAMIC_SEQRAM_158
	{0x3E5A, 0x0000},  // DYNAMIC_SEQRAM_15A
	{0x3E5C, 0x0000},  // DYNAMIC_SEQRAM_15C
	{0x3E5E, 0x0000},  // DYNAMIC_SEQRAM_15E
	{0x3E60, 0x0000},  // DYNAMIC_SEQRAM_160
	{0x3E62, 0x0000},  // DYNAMIC_SEQRAM_162
	{0x3E64, 0x0000},  // DYNAMIC_SEQRAM_164
	{0x3E66, 0x0000},  // DYNAMIC_SEQRAM_166
	{0x3E68, 0x0000},  // DYNAMIC_SEQRAM_168
	{0x3E6A, 0x0000},  // DYNAMIC_SEQRAM_16A
	{0x3E6C, 0x0000},  // DYNAMIC_SEQRAM_16C
	{0x3E6E, 0x0000},  // DYNAMIC_SEQRAM_16E
	{0x3E70, 0x0000},  // DYNAMIC_SEQRAM_170
	{0x3E72, 0x0000},  // DYNAMIC_SEQRAM_172
	{0x3E74, 0x0000},  // DYNAMIC_SEQRAM_174
	{0x3E76, 0x0000},  // DYNAMIC_SEQRAM_176
	{0x3E78, 0x0000},  // DYNAMIC_SEQRAM_178
	{0x3E7A, 0x0000},  // DYNAMIC_SEQRAM_17A
	{0x3E7C, 0x0000},  // DYNAMIC_SEQRAM_17C
	{0x3E7E, 0x0000},  // DYNAMIC_SEQRAM_17E
	{0x3E80, 0x0000},  // DYNAMIC_SEQRAM_180
	{0x3E82, 0x0000},  // DYNAMIC_SEQRAM_182
	{0x3E84, 0x0000},  // DYNAMIC_SEQRAM_184
	{0x3E86, 0x0000},  // DYNAMIC_SEQRAM_186
	{0x3E88, 0x0000},  // DYNAMIC_SEQRAM_188
	{0x3E8A, 0x0000},  // DYNAMIC_SEQRAM_18A
	{0x3E8C, 0x0000},  // DYNAMIC_SEQRAM_18C
	{0x3E8E, 0x0000},  // DYNAMIC_SEQRAM_18E
	{0x3E90, 0x0000},  // DYNAMIC_SEQRAM_190
	{0x3E92, 0x0000},  // DYNAMIC_SEQRAM_192
	{0x3E94, 0x0000},  // DYNAMIC_SEQRAM_194
	{0x3E96, 0x0000},  // DYNAMIC_SEQRAM_196
	{0x3E98, 0x0000},  // DYNAMIC_SEQRAM_198
	{0x3E9A, 0x0000},  // DYNAMIC_SEQRAM_19A
	{0x3E9C, 0x0000},  // DYNAMIC_SEQRAM_19C
	{0x3E9E, 0x0000},  // DYNAMIC_SEQRAM_19E
	{0x3EA0, 0x0000},  // DYNAMIC_SEQRAM_1A0
	{0x3EA2, 0x0000},  // DYNAMIC_SEQRAM_1A2
	{0x3EA4, 0x0000},  // DYNAMIC_SEQRAM_1A4
	{0x3EA6, 0x0000},  // DYNAMIC_SEQRAM_1A6
	{0x3EA8, 0x0000},  // DYNAMIC_SEQRAM_1A8
	{0x3EAA, 0x0000},  // DYNAMIC_SEQRAM_1AA
	{0x3EAC, 0x0000},  // DYNAMIC_SEQRAM_1AC
	{0x3EAE, 0x0000},  // DYNAMIC_SEQRAM_1AE
	{0x3EB0, 0x0000},  // DYNAMIC_SEQRAM_1B0
	{0x3EB2, 0x0000},  // DYNAMIC_SEQRAM_1B2
	{0x3EB4, 0x0000},  // DYNAMIC_SEQRAM_1B4
	{0x3EB6, 0x004C},  // DAC_LD_0_1
	{0x3EBA, 0xAAAA},  // DAC_LD_4_5
	{0x3EBC, 0x0086},  // DAC_LD_6_7
	{0x3EC0, 0x1E00},  // DAC_LD_10_11
	{0x3EC2, 0x000B},  // DAC_LD_12_13
	{0x3EC4, 0x3300},  // DAC_LD_14_15
	{0x3EC6, 0xEA44},  // DAC_LD_16_17
	{0x3EC8, 0x6F6F},  // DAC_LD_18_19
	{0x3ECA, 0x2F4A},  // DAC_LD_20_21
	{0x3ECC, 0x0506},  // DAC_LD_22_23
	{0x3ECE, 0x203B},  // DAC_LD_24_25
	{0x3ED0, 0x13F0},  // DAC_LD_26_27
	{0x3ED2, 0x9A3D},  // DAC_LD_28_29
	{0x3ED4, 0x862F},  // DAC_LD_30_31
	{0x3ED6, 0x4081},  // DAC_LD_32_33
	{0x3ED8, 0x4003},  // DAC_LD_34_35
	{0x3EDA, 0x9A80},  // DAC_LD_36_37
	{0x3EDC, 0xC000},  // DAC_LD_38_39
	{0x3EDE, 0xC103},  // DAC_LD_40_41
	{0x3426, 0x1600},  // AD_RESERVE_1_0
	{0x342A, 0x0038},  // PULSE_CONFIG
	{0x3F3E, 0x0001},  // ANALOG_CONTROL10
	{0x341A, 0x6051},  // AD_SH1_0
	{0x3420, 0x6051},  // AD_SH2_0
	{0x3EC2, 0x000A},  // DAC_LD_12_13
	{0x3ED8, 0x8003},  // DAC_LD_34_35
	{0x341A, 0x4735},  // AD_SH1_0
	{0x3420, 0x4735},  // AD_SH2_0
	{0x3426, 0x8A1A},  // AD_RESERVE_1_0
	{0x342A, 0x0018},  // PULSE_CONFIG
	{0x3ED2, 0xA53D},  // DAC_LD_28_29
	{0x3EDA, 0xA580},  // DAC_LD_36_37
	{0x3EBA, 0xAAAD},  // DAC_LD_4_5
	{0x3EB6, 0x004C},  // DAC_LD_0_1
	{0x3F3E, 0x0000},  // ANALOG_CONTROL10
	{0x31B0, 0x0058},  // FRAME_PREAMBLE
	{0x31B2, 0x002C},  // LINE_PREAMBLE
	{0x31B4, 0x23D2},  // MIPI_TIMING_0
	{0x31B6, 0x13E9},  // MIPI_TIMING_1
	{0x31B8, 0x2413},  // MIPI_TIMING_2
	{0x31BA, 0x1C68},  // MIPI_TIMING_3
	{0x31BC, 0x860B},  // MIPI_TIMING_4
	{0x0112, 0x0A0A},  // CCP_DATA_FORMAT
	{0x0304, 0x0303},  // PRE_PLL_CLK_DIV
	{0x0306, 0x7359},  // PLL_MULTIPLIER
	{0x0302, 0x0001},  // VT_SYS_CLK_DIV
	{0x030A, 0x0001},  // OP_SYS_CLK_DIV
	{0x0300, 0x0005},  // VT_PIX_CLK_DIV
	{0x0308, 0x000A},  // OP_PIX_CLK_DIV
	{0x3016, 0x0101},  // ROW_SPEED
	{0x3004, 0x0154},  // X_ADDR_START_
	{0x3008, 0x08DB},  // X_ADDR_END_
	{0x3002, 0x01B4},  // Y_ADDR_START_
	{0x3006, 0x05F3},  // Y_ADDR_END_
	{0x3040, 0x0041},  // READ_MODE
	{0x3172, 0x0206},  // ANALOG_CONTROL2
	{0x317A, 0x416E},  // ANALOG_CONTROL6
	{0x3F3C, 0x0003},  // ANALOG_CONTROL9
	{0x034C, 0x0780},  // X_OUTPUT_SIZE
	{0x034E, 0x0438},  // Y_OUTPUT_SIZE
	{0x300C, 0x1178},  // LINE_LENGTH_PCK_
	{0x300A, 0x0FC5},  // FRAME_LENGTH_LINES_
	{0x301A, 0x0210},  // RESET_REGISTER
	{0x301E, 0x00A8},  // DATA_PEDESTAL_
	{0x301A, 0x0218},  // RESET_REGISTER
	{0x30EE, 0x1136},  // DARK_CONTROL3
	{0x3F2C, 0x442E},  // GTH_THRES_RTN
	{0x301A, 0x0210},  // RESET_REGISTER
	{0x301E, 0x00AA},  // DATA_PEDESTAL_
	{0x301A, 0x0218},  // RESET_REGISTER
	{0x3120, 0x0005},  // DITHER_CONTROL
	{0x300C, 0x05F0},  // LINE_LENGTH_PCK_
	{0x300A, 0x0FC5},  // FRAME_LENGTH_LINES_
	{0x300A, 0x0FC3},  //
	{0x3012, 0x0A70},	//coarse integration time 
	{0x301A, 0x021C},  // RESET_REGISTER

#endif
};


static struct regval_list sensor_sxga_regs[] = { //SXGA: 1280*960@30fps 
};

//static struct regval_list sensor_xga_regs[] = { //XGA: 1024*768
//};


//static struct regval_list sensor_1080p_regs[] = { //1080: 1920*1080@30fps EIS
//};

//static struct regval_list sensor_720p_regs[] = { //720: 1280*720@60fps
//};

//static struct regval_list sensor_svga_regs[] = { //SVGA: 800*600
//};

//static struct regval_list sensor_vga_regs[] = { //VGA:  640*480
//};

/*
 * Here we'll try to encapsulate the changes for just the output
 * video format.
 * 
 */

static struct regval_list sensor_fmt_raw[] = {
    //{REG_TERM,VAL_TERM},
};

/*
 * Low-level register I/O.
 *
 */
static int sensor_read(struct v4l2_subdev *sd, unsigned short reg,
    unsigned short *value)
{
    int ret=0;
    int cnt=0;
	
    ret = cci_read_a16_d16(sd,reg,value);
    while(ret!=0&&cnt<3)
    {
    	ret = cci_read_a16_d16(sd,reg,value);
    	cnt++;
    }
    if(cnt>0)
    	vfe_dev_dbg("sensor read retry=%d\n",cnt);
		
    return ret;
}

static int sensor_write(struct v4l2_subdev *sd, unsigned short reg,
    unsigned short value)
{
    int ret=0;
    int cnt=0;
    ret = cci_write_a16_d16(sd,reg,value);
    while(ret !=0&&cnt<2)
    {
    	ret = cci_write_a16_d16(sd,reg,value);
    	cnt++;
    }
    if(cnt>=1)
    	vfe_dev_dbg("sensor write retry=%d\n",cnt);
    return ret;
}

/*
 * Write a list of register settings;
 */
static int sensor_write_array(struct v4l2_subdev *sd, struct regval_list *regs, int array_size)
{
    int i=0;

    if(!regs)
    	return -EINVAL;

    while(i<array_size)
    {
        if(regs->addr == REG_DLY) {
            msleep(regs->data);
        } 
        else 
        {  
            sensor_write(sd, regs->addr, regs->data);
        }
        i++;
        regs++;
    }
    return 0;
}

/* 
 * Code for dealing with controls.
 * fill with different sensor module
 * different sensor module has different settings here
 * if not support the follow function ,retrun -EINVAL
 */
static int sensor_g_exp(struct v4l2_subdev *sd, __s32 *value)
{
	struct sensor_info *info = to_state(sd);
	
	*value = info->exp;
	vfe_dev_dbg("sensor_get_exposure = %d\n", info->exp);
	return 0;
}

static int sensor_s_exp(struct v4l2_subdev *sd, unsigned int exp_val)
{
    struct sensor_info *info = to_state(sd);
	return 0;
    vfe_dev_dbg("sensor_set_exposure = %d\n", exp_val);
    if(exp_val>0xffffff)
        exp_val=0xfffff0;
    if(exp_val<16)
        exp_val=16;
  
    exp_val=(exp_val)>>4;//rounding to 1
    
    sensor_write(sd, 0x3012,exp_val);//coarse integration time
  
    info->exp = exp_val;
    return 0;
}

static int sensor_g_gain(struct v4l2_subdev *sd, __s32 *value)
{
    struct sensor_info *info = to_state(sd);
	
    *value = info->gain;
    vfe_dev_dbg("sensor_get_gain = %d\n", info->gain);
    return 0;
}

static int sensor_s_gain(struct v4l2_subdev *sd, int gain_val)
{
    struct sensor_info *info = to_state(sd);
	unsigned short dig_gain = 0x80;	// 1 times digital gain
	return 0;
    if (gain_val < 16)
        gain_val = 16;

    if (16<= gain_val*100 && gain_val*100 < (103*16) )
        sensor_write(sd,0x3060,0x0000);
    else if ((103*16) <= gain_val*100 && gain_val*100 < (107*16))
        sensor_write(sd,0x3060,0x0001);
    else if ((107*16) <= gain_val*100 && gain_val*100 < (110*16))
        sensor_write(sd,0x3060,0x0002);
    else if ((110*16) <= gain_val*100 && gain_val*100 < (114*16))
        sensor_write(sd,0x3060,0x0003);
    else if ((114*16) <= gain_val*100 && gain_val*100 < (119*16))
        sensor_write(sd,0x3060,0x0004);
    else if ((119*16) <= gain_val*100 && gain_val*100 < (123*16))
        sensor_write(sd,0x3060,0x0005);
    else if ((123*16) <= gain_val*100 && gain_val*100 < (128*16))
        sensor_write(sd,0x3060,0x0006);
    else if ((128*16) <= gain_val*100 && gain_val*100 < (133*16))
        sensor_write(sd,0x3060,0x0007);
    else if ((133*16) <= gain_val*100 && gain_val*100 < (139*16))
        sensor_write(sd,0x3060,0x0008);
    else if ((139*16) <= gain_val*100 && gain_val*100 < (145*16))
        sensor_write(sd,0x3060,0x0009);
    else if ((145*16) <= gain_val*100 && gain_val*100 < (152*16))
        sensor_write(sd,0x3060,0x000a);
    else if ((152*16) <= gain_val*100 && gain_val*100 < (160*16))
        sensor_write(sd,0x3060,0x000b);
    else if ((160*16) <= gain_val*100 && gain_val*100 < (168*16))
        sensor_write(sd,0x3060,0x000c);
    else if ((168*16) <= gain_val*100 && gain_val*100 < (178*16))
        sensor_write(sd,0x3060,0x000d);
    else if ((178*16) <= gain_val*100 && gain_val*100 < (188*16))
        sensor_write(sd,0x3060,0x000e);
    else if ((188*16) <= gain_val*100 && gain_val*100 < (200*16))
        sensor_write(sd,0x3060,0x000f);
    else if ((200*16) <= gain_val*100 && gain_val*100 < (213*16))
	{
        sensor_write(sd,0x3060,0x0010);
		dig_gain = gain_val*12800/(200*16);
	}
    else if ((213*16) <= gain_val*100 && gain_val*100 < (229*16))
    {
        sensor_write(sd,0x3060,0x0012);
		dig_gain = gain_val*12800/(213*16);
    }
    else if ((229*16) <= gain_val*100 && gain_val*100 < (246*16))
    {
        sensor_write(sd,0x3060,0x0014);
		dig_gain = gain_val*12800/(229*16);
    }
    else if ((246*16) <= gain_val*100 && gain_val*100 < (267*16))
	{
		sensor_write(sd,0x3060,0x0016);
		dig_gain = gain_val*12800/(246*16);
	}
    else if ((267*16) <= gain_val*100 && gain_val*100 < (291*16))
	{
		sensor_write(sd,0x3060,0x0018);
		dig_gain = gain_val*12800/(267*16);
	}
    else if ((291*16) <= gain_val*100 && gain_val*100 < (320*16))
	{
		sensor_write(sd,0x3060,0x001a);
		dig_gain = gain_val*12800/(291*16);
	}
    else if ((320*16) <= gain_val*100 && gain_val*100 < (356*16))
	{
		sensor_write(sd,0x3060,0x001c);
		dig_gain = gain_val*12800/(320*16);
	}
    else if ((356*16) <= gain_val*100 && gain_val*100 < (400*16))
	{
		sensor_write(sd,0x3060,0x001e);
		dig_gain = gain_val*12800/(356*16);
	}
    else if ((400*16) <= gain_val*100 && gain_val*100 < (457*16))
	{
		sensor_write(sd,0x3060,0x0020);
		dig_gain = gain_val*12800/(400*16);
	}
    else if ((457*16) <= gain_val*100 && gain_val*100 < (533*16))
	{
		sensor_write(sd,0x3060,0x0024);
		dig_gain = gain_val*12800/(457*16);
	}
    else if ((533*16) <= gain_val*100 && gain_val*100 < (640*16))
	{
		sensor_write(sd,0x3060,0x0028);
		dig_gain = gain_val*12800/(533*16);
	}
    else if ((640*16) <= gain_val*100 && gain_val*100 < (800*16))
	{
		sensor_write(sd,0x3060,0x002c);
		dig_gain = gain_val*12800/(640*16);
	}
    else if ((800*16) <= gain_val*100 )
	{
		sensor_write(sd,0x3060,0x0030);
		dig_gain = gain_val*12800/(800*16);
	}

	sensor_write(sd, 0x305e, dig_gain);
    
    //sensor_read(sd,0x3060,&tmp_gain);
    //printk("sensor_set_gain = %d,readout gain =0x%x\n", gain_val,tmp_gain);
    info->gain = gain_val;
    return 0;
}

static int ar0330_sensor_vts;
static int sensor_s_exp_gain(struct v4l2_subdev *sd, struct sensor_exp_gain *exp_gain)
{
    int exp_val, gain_val,shutter,frame_length;  
    //  unsigned char explow=0,expmid=0,exphigh=0,vts_diff_low,vts_diff_high;
    //  unsigned char gainlow=0,gainhigh=0;  
	return 0;
    struct sensor_info *info = to_state(sd);
    exp_val = exp_gain->exp_val;
    gain_val = exp_gain->gain_val;
    if(gain_val<1*16)
        gain_val=16;
    if(gain_val>64*16-1)
        gain_val=64*16-1;
    if(exp_val>0xfffff)
        exp_val=0xfffff;

    shutter = exp_val/16;
    if(shutter > ar0330_sensor_vts - 4)
    	frame_length = shutter + 4;
    else
    	frame_length = ar0330_sensor_vts;

//    printk("norm exp_val = %d,gain_val = %d\n",exp_val,gain_val);
//   sensor_write(sd, 0x300A,frame_length);//coarse integration time
    sensor_s_exp(sd,exp_val);
    sensor_s_gain(sd,gain_val);
    info->exp = exp_val;
    info->gain = gain_val;
    return 0;
}
static int sensor_s_sw_stby(struct v4l2_subdev *sd, int on_off)
{
    int ret ;
    unsigned short rdtmp;
    ret = sensor_read(sd,0x0100,&rdtmp);
    if (ret!=0)
        return ret;
    if (on_off == CSI_STBY_ON)
        sensor_write(sd,0x0100, 0x00);
    else 
        sensor_write(sd,0x0100, 0x01);
    return ret;
}

/*
 * Stuff that knows about the sensor.
 */
 
static int sensor_power(struct v4l2_subdev *sd, int on)
{
	int ret;
	ret = 0;
	switch(on)
	{
		case CSI_SUBDEV_STBY_ON:
			vfe_dev_dbg("CSI_SUBDEV_STBY_ON!\n");
			//software standby on
			ret = sensor_s_sw_stby(sd, CSI_STBY_ON);
			if(ret < 0)
				vfe_dev_err("soft stby falied!\n");
			usleep_range(10000,12000);
			cci_lock(sd);
			//vfe_gpio_write(sd,PWDN,CSI_GPIO_LOW);
			cci_unlock(sd);
			vfe_set_mclk(sd,OFF);
			break;
		case CSI_SUBDEV_STBY_OFF:
			vfe_dev_dbg("CSI_SUBDEV_STBY_OFF!\n");
			cci_lock(sd);
			vfe_set_mclk_freq(sd,MCLK);
			vfe_set_mclk(sd,ON);
			usleep_range(10000,12000);
			//vfe_gpio_write(sd,PWDN,CSI_GPIO_HIGH);
			//usleep_range(10000,12000);
			ret = sensor_s_sw_stby(sd, CSI_STBY_OFF);
			if(ret < 0)
				vfe_dev_err("soft stby off falied!\n");
			cci_unlock(sd);
			break;
		case CSI_SUBDEV_PWR_ON:
			vfe_dev_dbg("CSI_SUBDEV_PWR_ON!\n");
			cci_lock(sd);
			//power on reset
			//vfe_gpio_set_status(sd,PWDN,1);//set the gpio to output
			vfe_gpio_set_status(sd,RESET,1);//set the gpio to output
//			vfe_gpio_set_status(sd,POWER_EN,1);//set the gpio to output 
			
			vfe_gpio_write(sd,RESET,CSI_GPIO_LOW);  //1:set reset to low

			vfe_set_pmu_channel(sd,IOVDD,ON);	//2:power up IOVDD
			//usleep_range(1000,1200);
			msleep(1);
			//power supply
			vfe_set_pmu_channel(sd,AVDD,ON);	//3:power up AVDD/DVDD etc
			//usleep_range(1000,1200);
			msleep(1);
			vfe_set_pmu_channel(sd,DVDD,ON);
			//usleep_range(1000,1200);
			msleep(1);
			//active mclk before power on
			vfe_set_mclk_freq(sd,MCLK);		//4:apply extclk
			vfe_set_mclk(sd,ON);
			//usleep_range(1000,12000);
			msleep(1);

			//reset on io
			vfe_gpio_write(sd,RESET,CSI_GPIO_HIGH);	//5:set reset to high
			//usleep_range(10000,12000);
			msleep(10);
			cci_unlock(sd);
			break;
		case CSI_SUBDEV_PWR_OFF:
			vfe_dev_dbg("CSI_SUBDEV_PWR_OFF!\n");
			cci_lock(sd);
//			vfe_gpio_set_status(sd,PWDN,1);//set the gpio to output
//			vfe_gpio_set_status(sd,RESET,1);//set the gpio to output
			vfe_gpio_write(sd,RESET,CSI_GPIO_LOW);  
//			vfe_gpio_write(sd,PWDN,CSI_GPIO_HIGH);
			//power supply off
			//vfe_set_pmu_channel(sd,AFVDD,OFF);
			vfe_set_pmu_channel(sd,DVDD,OFF);
//			vfe_gpio_write(sd,POWER_EN,CSI_GPIO_LOW);
			vfe_set_pmu_channel(sd,AVDD,OFF);
			vfe_set_pmu_channel(sd,IOVDD,OFF);
			//inactive mclk before power off
			vfe_set_mclk(sd,OFF);
			//set the io to hi-z
			vfe_gpio_set_status(sd,RESET,0);//set the gpio to input
			//vfe_gpio_set_status(sd,PWDN,0);//set the gpio to input
//			vfe_gpio_set_status(sd,POWER_EN,0);//set the gpio to input
			cci_unlock(sd);
			usleep_range(50000,52000);  
			break;
		default:
			return -EINVAL;
	}

	return 0;
}
 
static int sensor_reset(struct v4l2_subdev *sd, u32 val)
{
	vfe_dev_dbg("sensor_reset val=%d!\n",val);
    switch(val)
    {
        case 0:
            vfe_gpio_write(sd,RESET,CSI_RST_OFF);
            usleep_range(10000,12000);
            break;
        case 1:
            vfe_gpio_write(sd,RESET,CSI_RST_ON);
            usleep_range(10000,12000);
            break;
        default:
            return -EINVAL;
    }
    return 0;
}

static int sensor_detect(struct v4l2_subdev *sd)
{
    unsigned short rdval = 0;
	return 0;
    LOG_ERR_RET(sensor_read(sd, 0x0000, &rdval))
    if(rdval != 0x0457)
    {
        printk(KERN_DEBUG"*********sensor error,read id is %x.\n",rdval);
        return -ENODEV;
    }
    else
    {
        printk(KERN_DEBUG"*********find ar0521_mipi raw data camera sensor now.id=0x%x\n",rdval);
        return 0;
    }
}

extern void switch_to_cn1();
extern void switch_to_cn3();
static int sensor_init(struct v4l2_subdev *sd, u32 val)
{
    int ret;
    struct sensor_info *info = to_state(sd);

    vfe_dev_dbg("sensor_init\n");

    /*Make sure it is a target sensor*/
    ret = sensor_detect(sd);
    if (ret) {
        vfe_dev_err("chip found is not an target chip.\n");
        return ret;
    }
    vfe_get_standby_mode(sd,&info->stby_mode);

    if((info->stby_mode == HW_STBY || info->stby_mode == SW_STBY) \
            && info->init_first_flag == 0) {
        vfe_dev_print("stby_mode and init_first_flag = 0\n");
        return 0;
    } 

    info->focus_status = 0;
    info->low_speed = 0;
    info->width = HD1080_WIDTH;
    info->height = HD1080_HEIGHT;
    info->hflip = 0;
    info->vflip = 0;
    info->gain = 0;

    info->tpf.numerator = 1;            
    info->tpf.denominator = 30;    /* 30fps */ 

    ret = sensor_write_array(sd, sensor_default_regs, ARRAY_SIZE(sensor_default_regs));  
    if(ret < 0) {
        vfe_dev_err("write sensor_default_regs error\n");
        return ret;
    }

	{//init cn3 port camera
		switch_to_cn3();
		msleep(20);
		ret = sensor_write_array(sd, sensor_default_regs, ARRAY_SIZE(sensor_default_regs));  
	    if(ret < 0) {
	        vfe_dev_err("write sensor_default_regs error\n");
	        return ret;
	    }
		msleep(20);
		switch_to_cn1();
	}
	
    if(info->stby_mode == 0)
    info->init_first_flag = 0;
    info->preview_first_flag = 1;
    return 0;
}

static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
{
    int ret=0;
    struct sensor_info *info = to_state(sd);
    switch(cmd) {
    case GET_CURRENT_WIN_CFG:
        if(info->current_wins != NULL)
        {
            memcpy( arg,
                    info->current_wins,
                    sizeof(struct sensor_win_size) );
            ret=0;
        }
        else
        {
            vfe_dev_err("empty wins!\n");
            ret=-1;
        }
        break;
    case SET_FPS:
        ret=0;
        break;
    case ISP_SET_EXP_GAIN:
        ret = sensor_s_exp_gain(sd, (struct sensor_exp_gain *)arg);
        break;
    default:
        return -EINVAL;
    }
    return ret;
}


/*
 * Store information about the video data format. 
 */
static struct sensor_format_struct {
    __u8 *desc;
    //__u32 pixelformat;
    enum v4l2_mbus_pixelcode mbus_code;
    struct regval_list *regs;
    int regs_size;
    int bpp;   /* Bytes per pixel */
}sensor_formats[] = {
	{
		.desc		= "Raw RGB Bayer",
		//.mbus_code	= V4L2_MBUS_FMT_SBGGR10_10X1,
		//.mbus_code	= V4L2_MBUS_FMT_SGBRG10_10X1,
		.mbus_code	= V4L2_MBUS_FMT_SGRBG10_10X1,
		//.mbus_code	= V4L2_MBUS_FMT_SRGGB10_10X1,
		.regs 		= sensor_fmt_raw,
		.regs_size = ARRAY_SIZE(sensor_fmt_raw),
		.bpp		= 1
	},
};
#define N_FMTS ARRAY_SIZE(sensor_formats)

/*
 * Then there is the issue of window sizes.  Try to capture the info here.
 */
static struct sensor_win_size sensor_win_sizes[] = {
    /* qsxga: 2304*1296 */  
   /* {
        .width      = 2304,
        .height     = 1296,
        .hoffset    = 0,
        .voffset    = 0,
        .hts        = 1248,
        .vts        = 1308,
        .pclk       = 49*1000*1000,
        .mipi_bps	= (588*1000*1000),
        .fps_fixed  = 1,
        .bin_factor = 1,
        .intg_min   = 1<<4,
        .intg_max   = 1308<<4,//
        .gain_min   = 1<<4,
        .gain_max   = 64<<4,
        .regs       = sensor_default_regs,
        .regs_size  = ARRAY_SIZE(sensor_default_regs),
        .set_size   = NULL,
    },*/
    /*{
      .width      = HD1080_WIDTH,
      .height     = HD1080_HEIGHT,
      .regs       = sensor_sxga_regs,
      .regs_size  = ARRAY_SIZE(sensor_sxga_regs),
      .set_size   = NULL,
	  },*/
    /* 1080P */
    {
        .width	    = HD1080_WIDTH,
        .height 	= HD1080_HEIGHT,
        .hoffset    = 0,
        .voffset    = 0,
        .hts        = 2800,
        .vts        = 2000,
        .pclk       = 49*1000*1000,
        .mipi_bps	= (588*1000*1000)/1,
        /*.fps_fixed  = 1,
        .bin_factor = 1,
        .intg_min   = 1<<4,
        .intg_max   = 1308<<4,//
        .gain_min   = 1<<4,
        .gain_max   = 64<<4,
        .width_input = 1920,
		.height_input = 1080,*/
        .regs       = sensor_default_regs,
        .regs_size  = ARRAY_SIZE(sensor_default_regs),
        .set_size   = NULL,
    },
//    /* 1080P */
//    {
//      .width			= HD1080_WIDTH,
//      .height 		= HD1080_HEIGHT,
//      .hoffset	  = 0,
//      .voffset	  = 0,
//      .hts        = 2800,//must over 2738, limited by sensor
//      .vts        = 2000,
//      .pclk       = 84*1000*1000,
//      .fps_fixed  = 1,
//      .bin_factor = 1,
//      .intg_min   = 3<<4,
//      .intg_max   = (1200-8)<<4,
//      .gain_min   = 1<<4,
//      .gain_max   = 16<<4,
//      .regs       = sensor_1080p_regs,//
//      .regs_size  = ARRAY_SIZE(sensor_1080p_regs),//
//      .set_size		= NULL,
//    },
	/* UXGA */
//	{
//      .width			= UXGA_WIDTH,
//      .height 		= UXGA_HEIGHT,
//      .hoffset	  = 0,
//      .voffset	  = 0,
//      .hts        = 2800,//limited by sensor
//      .vts        = 1000,
//      .pclk       = 84*1000*1000,
//      .fps_fixed  = 1,
//      .bin_factor = 1,
//      .intg_min   = ,
//      .intg_max   = ,
//      .gain_min   = ,
//      .gain_max   = ,
//      .regs			= sensor_uxga_regs,
//      .regs_size	= ARRAY_SIZE(sensor_uxga_regs),
//      .set_size		= NULL,
//	},
  	/* SXGA */
#if 0
    {
      .width			= SXGA_WIDTH,
      .height 		= SXGA_HEIGHT,
      .hoffset	  = 0,
      .voffset	  = 0,
      .hts        = 2800,//must > 2738, limited by sensor
      .vts        = 1000,
      .pclk       = 84*1000*1000,
      .mipi_bps		= 200*1000*1000,
      .fps_fixed  = 1,
      .bin_factor = 1,
      .intg_min   = 3<<4,
      .intg_max   = (1000-8)<<4,
      .gain_min   = 1<<4,
      .gain_max   = 16<<4,
      .regs		    = sensor_sxga_regs,
      .regs_size	= ARRAY_SIZE(sensor_sxga_regs),
      .set_size		= NULL,
    },
    /* 720p */
    {
      .width      = HD720_WIDTH,
      .height     = HD720_HEIGHT,
      .hoffset    = 0,
      .voffset    = 0,
      .hts        = 2800,//must > 2738, limited by sensor
      .vts        = 1000,
      .pclk       = 84*1000*1000,
      .mipi_bps		= 200*1000*1000,
      .fps_fixed  = 1,
      .bin_factor = 1,
      .intg_min   = 3<<4,
      .intg_max   = (1000-8)<<4,
      .gain_min   = 1<<4,
      .gain_max   = 16<<4,
      .regs			  = sensor_720p_regs,//
      .regs_size	= ARRAY_SIZE(sensor_720p_regs),//
      .set_size		= NULL,
    },
 #endif
    /* XGA */
//    {
//      .width			= XGA_WIDTH,
//      .height 		= XGA_HEIGHT,
//      .hoffset    = 0,
//      .voffset    = 0,
//      .hts        = 2800,//limited by sensor
//      .vts        = 1000,
//      .pclk       = 84*1000*1000,
//      .fps_fixed  = 1,
//      .bin_factor = 1,
//      .intg_min   = ,
//      .intg_max   = ,
//      .gain_min   = ,
//      .gain_max   = ,
//      .regs			  = sensor_xga_regs,
//      .regs_size	= ARRAY_SIZE(sensor_xga_regs),
//      .set_size		= NULL,
//    },
  /* SVGA */
//    {
//      .width			= SVGA_WIDTH,
//      .height 		= SVGA_HEIGHT,
//      .hoffset	  = 0,
//      .voffset	  = 0,
//      .hts        = 2800,//limited by sensor
//      .vts        = 1000,
//      .pclk       = 84*1000*1000,
//      .fps_fixed  = 1,
//      .bin_factor = 1,
//      .intg_min   = ,
//      .intg_max   = ,
//      .gain_min   = ,
//      .gain_max   = ,
//      .regs       = sensor_svga_regs,
//      .regs_size  = ARRAY_SIZE(sensor_svga_regs),
//      .set_size   = NULL,
//    },
  /* VGA */
//    {
//      .width			= VGA_WIDTH,
//      .height 		= VGA_HEIGHT,
//      .hoffset	  = 0,
//      .voffset	  = 0,
//      .hts        = 2800,//limited by sensor
//      .vts        = 1000,
//      .pclk       = 84*1000*1000,
//      .fps_fixed  = 1,
//      .bin_factor = 1,
//      .intg_min   = ,
//      .intg_max   = ,
//      .gain_min   = ,
//      .gain_max   = ,
//      .regs       = sensor_vga_regs,
//      .regs_size  = ARRAY_SIZE(sensor_vga_regs),
//      .set_size   = NULL,
//    },
};

#define N_WIN_SIZES (ARRAY_SIZE(sensor_win_sizes))

static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned index,
                 enum v4l2_mbus_pixelcode *code)
{
    if (index >= N_FMTS)
        return -EINVAL;

    *code = sensor_formats[index].mbus_code;
    return 0;
}

static int sensor_enum_size(struct v4l2_subdev *sd,
                            struct v4l2_frmsizeenum *fsize)
{
    if(fsize->index > N_WIN_SIZES-1)
    	return -EINVAL;
  
    fsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;
    fsize->discrete.width = sensor_win_sizes[fsize->index].width;
    fsize->discrete.height = sensor_win_sizes[fsize->index].height;
  
    return 0;
}

static int sensor_try_fmt_internal(struct v4l2_subdev *sd,
    struct v4l2_mbus_framefmt *fmt,
    struct sensor_format_struct **ret_fmt,
    struct sensor_win_size **ret_wsize)
{
    int index;
    struct sensor_win_size *wsize;
    struct sensor_info *info = to_state(sd);

    for (index = 0; index < N_FMTS; index++)
        if (sensor_formats[index].mbus_code == fmt->code)
            break;

    if (index >= N_FMTS) 
        return -EINVAL;
  
    if (ret_fmt != NULL)
        *ret_fmt = sensor_formats + index;
    
    /*
    * Fields: the sensor devices claim to be progressive.
    */
  
    fmt->field = V4L2_FIELD_NONE;
  
    /*
    * Round requested image size down to the nearest
    * we support, but not below the smallest.
    */
    for (wsize = sensor_win_sizes; wsize < sensor_win_sizes + N_WIN_SIZES;
       wsize++)
        if (fmt->width >= wsize->width && fmt->height >= wsize->height)
            break;
    
    if (wsize >= sensor_win_sizes + N_WIN_SIZES)
        wsize--;   /* Take the smallest one */
    if (ret_wsize != NULL)
        *ret_wsize = wsize;
    /*
    * Note the size we'll actually handle.
    */
    fmt->width = wsize->width;
    fmt->height = wsize->height;
    info->current_wins = wsize;
    //pix->bytesperline = pix->width*sensor_formats[index].bpp;
    //pix->sizeimage = pix->height*pix->bytesperline;

    return 0;
}

static int sensor_try_fmt(struct v4l2_subdev *sd, 
             struct v4l2_mbus_framefmt *fmt)
{
    return sensor_try_fmt_internal(sd, fmt, NULL, NULL);
}

static int sensor_g_mbus_config(struct v4l2_subdev *sd,
           struct v4l2_mbus_config *cfg)
{
    cfg->type = V4L2_MBUS_CSI2;
  cfg->flags = 0|V4L2_MBUS_CSI2_4_LANE|V4L2_MBUS_CSI2_CHANNEL_0;
  
    return 0;
}


/*
 * Set a format.
 */
static int sensor_s_fmt(struct v4l2_subdev *sd, 
             struct v4l2_mbus_framefmt *fmt)
{
    int ret;
    struct sensor_format_struct *sensor_fmt;
    struct sensor_win_size *wsize;
    struct sensor_info *info = to_state(sd);
	
    vfe_dev_dbg("sensor_s_fmt,fmt->code=0x%x\n",fmt->code);
    //  sensor_write_array(sd, sensor_oe_disable_regs, ARRAY_SIZE(sensor_oe_disable_regs));
    ret = sensor_try_fmt_internal(sd, fmt, &sensor_fmt, &wsize);
    vfe_dev_dbg("sensor_s_fmt  ret = %d\n",ret);
    if (ret)
        return ret;
    if(info->capture_mode == V4L2_MODE_VIDEO)
    {
        //video
    }
    else if(info->capture_mode == V4L2_MODE_IMAGE)
    {
        //image
    }
    LOG_ERR_RET(sensor_write_array(sd, sensor_fmt->regs, sensor_fmt->regs_size))
    ret = 0;
    if (wsize->regs)
        LOG_ERR_RET(sensor_write_array(sd, wsize->regs, wsize->regs_size))
    if (wsize->set_size)
        LOG_ERR_RET(wsize->set_size(sd))
		

    info->fmt = sensor_fmt;
    info->width = wsize->width;
    info->height = wsize->height;
    ar0330_sensor_vts = wsize->vts;
    // show_regs_array(sd,sensor_1080p_regs);

    vfe_dev_print("s_fmt set width = %d, height = %d\n",wsize->width,wsize->height);
    if(info->capture_mode == V4L2_MODE_VIDEO)
    {
        //video
    } else {
        //capture image
    }
    //sensor_write_array(sd, sensor_oe_enable_regs, ARRAY_SIZE(sensor_oe_enable_regs));
    return 0;
}

/*
 * Implement G/S_PARM.  There is a "high quality" mode we could try
 * to do someday; for now, we just do the frame rate tweak.
 */
static int sensor_g_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
{
    struct v4l2_captureparm *cp = &parms->parm.capture;
    struct sensor_info *info = to_state(sd);

    if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
        return -EINVAL;
  
    memset(cp, 0, sizeof(struct v4l2_captureparm));
    cp->capability = V4L2_CAP_TIMEPERFRAME;
    cp->capturemode = info->capture_mode;
     
    return 0;
}

static int sensor_s_parm(struct v4l2_subdev *sd, struct v4l2_streamparm *parms)
{
    struct v4l2_captureparm *cp = &parms->parm.capture;
    //struct v4l2_fract *tpf = &cp->timeperframe;
    struct sensor_info *info = to_state(sd);
    //unsigned char div;
  
    vfe_dev_dbg("sensor_s_parm\n");
  
    if (parms->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
        return -EINVAL;
  
    if (info->tpf.numerator == 0)
        return -EINVAL;
    
    info->capture_mode = cp->capturemode;
  
    return 0;
}


static int sensor_queryctrl(struct v4l2_subdev *sd,
    struct v4l2_queryctrl *qc)
{
    /* Fill in min, max, step and default value for these controls. */
    /* see include/linux/videodev2.h for details */

    switch (qc->id) {
    case V4L2_CID_GAIN:
    	return v4l2_ctrl_query_fill(qc, 1*16, 16*9-1, 1, 16);
    case V4L2_CID_EXPOSURE:
    	return v4l2_ctrl_query_fill(qc, 1, 65536*16, 1, 1);
    case V4L2_CID_FRAME_RATE:
    	return v4l2_ctrl_query_fill(qc, 15, 120, 1, 30);
    }
    return -EINVAL;
}

static int sensor_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
    switch (ctrl->id) {
    case V4L2_CID_GAIN:
    	return sensor_g_gain(sd, &ctrl->value);
    case V4L2_CID_EXPOSURE:
    	return sensor_g_exp(sd, &ctrl->value);
    }
    return -EINVAL;
}

static int sensor_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
{
    struct v4l2_queryctrl qc;
    int ret;

    qc.id = ctrl->id;
    ret = sensor_queryctrl(sd, &qc);
    if (ret < 0) {
        return ret;
    }

    if (ctrl->value < qc.minimum || ctrl->value > qc.maximum) {
        return -ERANGE;
    }

    switch (ctrl->id) {
   /* case V4L2_CID_GAIN:
        return sensor_s_gain(sd, ctrl->value);      
    case V4L2_CID_EXPOSURE:
        return sensor_s_exp(sd, ctrl->value);*/
    }
    return -EINVAL;
}


static int sensor_g_chip_ident(struct v4l2_subdev *sd,
    struct v4l2_dbg_chip_ident *chip)
{
    struct i2c_client *client = v4l2_get_subdevdata(sd);

    return v4l2_chip_ident_i2c_client(client, chip, V4L2_IDENT_SENSOR, 0);
}


/* ----------------------------------------------------------------------- */

static const struct v4l2_subdev_core_ops sensor_core_ops = {
    .g_chip_ident = sensor_g_chip_ident,
    .g_ctrl = sensor_g_ctrl,
    .s_ctrl = sensor_s_ctrl,
    .queryctrl = sensor_queryctrl,
    .reset = sensor_reset,
    .init = sensor_init,
    .s_power = sensor_power,
    .ioctl = sensor_ioctl,
};

static const struct v4l2_subdev_video_ops sensor_video_ops = {
    .enum_mbus_fmt = sensor_enum_fmt,
    .enum_framesizes = sensor_enum_size,
    .try_mbus_fmt = sensor_try_fmt,
    .s_mbus_fmt = sensor_s_fmt,
    .s_parm = sensor_s_parm,
    .g_parm = sensor_g_parm,
    .g_mbus_config = sensor_g_mbus_config,
};

static const struct v4l2_subdev_ops sensor_ops = {
    .core = &sensor_core_ops,
    .video = &sensor_video_ops,
};

/* ----------------------------------------------------------------------- */
static struct cci_driver cci_drv = {
    .name = SENSOR_NAME,
    .addr_width = CCI_BITS_16,
    .data_width = CCI_BITS_16,
};

static int sensor_probe(struct i2c_client *client,
      const struct i2c_device_id *id)
{
    struct v4l2_subdev *sd;
    struct sensor_info *info;

    info = kzalloc(sizeof(struct sensor_info), GFP_KERNEL);
    if (info == NULL)
        return -ENOMEM;
    sd = &info->sd;
    glb_sd = sd;
    cci_dev_probe_helper(sd, client, &sensor_ops, &cci_drv);

    info->fmt = &sensor_formats[0];
    info->af_first_flag = 1;
    info->init_first_flag = 1;

    return 0;
}


static int sensor_remove(struct i2c_client *client)
{
    struct v4l2_subdev * sd;

    sd = cci_dev_remove_helper(client, &cci_drv);
    kfree(to_state(sd));
    return 0;
}

static const struct i2c_device_id sensor_id[] = {
    { SENSOR_NAME, 0 },
    { }
};
MODULE_DEVICE_TABLE(i2c, sensor_id);


static struct i2c_driver sensor_driver = {
    .driver = {
        .owner = THIS_MODULE,
        .name = SENSOR_NAME,
    },
    .probe = sensor_probe,
    .remove = sensor_remove,
    .id_table = sensor_id,
};
static __init int init_sensor(void)
{
	return cci_dev_init_helper(&sensor_driver);
}

static __exit void exit_sensor(void)
{
	cci_dev_exit_helper(&sensor_driver);
}

module_init(init_sensor);
module_exit(exit_sensor);
